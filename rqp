#!/usr/bin/env python

import optparse, os, sys, re, datetime, commands
import MySQLdb
from glob import glob
#import MySQLdb.connect

re_srpm = re.compile(r'\.src\.rpm$')
re_brpm = re.compile(r'\.rpm$')

#
# function to connect to the database
#
def db_connect(type):
    global config

    if config['hostspec'] == '':
        sys.stderr.write('Missing hostspec in the configuration!\n')
        exit(1)
    if config['username'] == '':
        sys.stderr.write('Missing username in the configuration!\n')
        exit(1)
    if config['password'] == '':
        sys.stderr.write('Missing password in the configuration!\n')
        exit(1)

    if type == 'binary':
        if (config['rpm_database'] == ''):
            sys.stderr.write('Missing rpm_database in the configuration!\n')
            exit(1)
        else:
            config['database'] = config['rpm_database']

    if type == 'source':
        if (config['srpm_database'] == ''):
            sys.stderr.write('Missing srpm_database in the configuration!\n')
            exit(1)
        else:
            config['database'] = config['srpm_database']

    print_debug('Using host=>%s, user=>%s, db=>%s' % (config['hostspec'], config['username'], config['database']))

    try:
        db = MySQLdb.connect(host=config['hostspec'],
                             user=config['username'],
                             passwd=config['password'],
                             db=config['database'])
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        exit(1)

    return db


#
# function to close connections to the database
#
def db_close():
    db.commit()
    db.close()


#
# function to perform database queries
#
def db_fetchall(query):
    print_debug('  in db_fetchall()')
    print_debug('  => query is: %s' % query)

    try:
        cursor = db.cursor()
        cursor.execute("set autocommit=0")
        cursor.execute(query)
        results = cursor.fetchall()
        cursor.close()

        if results:
            return results
        else:
            return False
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        exit(1)


#
# function to perform a single database query
#
def db_fetchone(query):
    print_debug('  in db_fetchone()')
    print_debug('  => query is: %s' % query)

    try:
        cursor = db.cursor()
        cursor.execute(query)
        results = cursor.fetchone()
        cursor.close()
        if results:
            return results[0]
        else:
            return False
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        exit(1)


#
# function to perform an actual query (non-SELECT) from the database
#
def db_doquery(query):
    print_debug('  in db_doquery()')
    print_debug('  => query is: %s' % query)

    try:
        cursor = db.cursor()
        cursor.execute(query)
        cursor.close()
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        exit(1)


#
# function to print debug strings
#
def print_debug(string):
    if options.debug:
        sys.stderr.write("=> DEBUG: %s\n" % string)


#
# function to print verbose strings
#
def print_verbose(string):
    if options.verbose:
        sys.stdout.write("%s\n" % string)


#
# function to read the configuration file
#
def read_config(config_file):
    config = {}
    configfile = open(config_file, 'r')
    for line in configfile:
        # strip the line return "\n" please note config files made in Windows
        # may fail since they use "\r\n" or whatever it is
        line = line.rstrip()
        # Ignore empty lines
        if not line:
            continue
        # Ignore commented lines
        if line.startswith("#"):
            continue
        if line.startswith(";"):
            continue
        #
        # Split on the first "=", passwords/etc can have a "=" in them this way
        # But configuration names cannot have "=" in them
        #
        (config_name, config_value) = line.split("=", 1)
        config_name         = config_name.strip()
        config[config_name] = config_value

    return config


#
# function to show database tags
#
def tag_list():
    print_debug("in tag_list()")

    query = 'SELECT tag, path, tdate FROM tags ORDER BY tag'
    results = db_fetchall(query)
    if results:
        for row in results:
            print 'Tag: %-22sDate Added: %-18s\n  Path: %s\n' % (row[0], row[2], row[1])
    else:
        print 'No tags exist in the database!\n'

    db_close()
    exit(0)


#
# function to delete database tags and associated entries
#
def tag_delete_entries(tag):
    print_debug('in tag_delete_entries(%s)' % tag)

    to_remove = []

    query  = "SELECT tag FROM tags WHERE tag = '%s' LIMIT 1" % tag
    result = db_fetchone(query)

    if not result:
        print 'No matching tag found for entry %s!\n' % tag
        exit(1)
    else:
        show_progress(tag)
        print_verbose('Remove %s from Tags...\n' % tag)
        query = "DELETE FROM tags WHERE tag = '%s'" % tag
        db_doquery(query)

        query  = "SELECT DISTINCT p_record FROM packages WHERE p_tag = '%s'" % tag
        result = db_fetchall(query)
        if result:
            while row in result:
                to_remove.append(row['p_record'])

        if len(to_remove) > 0:
            nrecs = len(to_remove)
            print_verbose('Removing %d tagged Packages (and associated Requires, Provides, and Files) entries for %s...\n' % (nrecs, tag))
            for rnum in to_remove:
                show_progress()
                query = "DELETE FROM packages WHERE p_record = '%d'" % rnum
                res   = db_doquery(query)
                query = "DELETE FROM requires WHERE record = '%d'" % rnum
                res   = db_doquery(query)
                query = "DELETE FROM provides WHERE record = '%d'" % rnum
                res   = db_doquery(query)
                query = "DELETE FROM files WHERE record = '%d'" % rnum
                res   = db_doquery(query)

        if options.progress:
            print '\n'


#
# function to update entries for a given tag
#
def tag_update_entries(tag):
    print_debug('in tag_update_entries(%s)' % tag)
    #
    # this function is designed for src.rpm handling, but we can update it for binary rpm handling too
    # XXX: TODO
    #

    to_remove = []
    to_add    = []

    query = "SELECT DISTINCT path FROM tags WHERE tag = '%s' LIMIT 1" % tag
    path  = db_fetchone(query)
    if path:
        print_verbose('Update tag (%s) entries from %s...' % (tag, path))
        # get the existing entries
        query  = "SELECT DISTINCT p_record, p_tag, p_package, p_vesion, p_release FROM packages WHERE p_tag = '%s'" % tag
        result = db_fetchall(query)
        for row in result:
            pname = '%s-%s-%s.src.rpm' % (row[3], row[4], row[5])
            print_verbose('Checking for %s in %s...' % (pname, path))
            if os.path.isfile(pname):
                print_verbose('OK')
            else:
                print_verbose('Missing')
                to_remove.append(result[0])
        for src_rpm in glob(path + "/*.rpm"):
            print_verbose('Checking for %s in database...' % src_rpm)
            rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}' " + src_rpm)
            tlist   = rtags.split('|')
            package = tlist[0].strip()
            version = tlist[1].strip()
            release = tlist[2].strip()

            query   = "SELECT p_package FROM packages WHERE p_tag = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (tag, package, version, release)
            package = db_fetchone(query)
            if package:
                print_verbose('OK')
            else:
                print_verbose('Adding')
                to_add.append(src_rpm)
    else:
        sys.stdout.write('No Tag entry found for tag: %s\n' % tag)

    if to_remove:
        print_verbose('Removing tagged entries for tag: %s...' % tag)
        for rnum in to_remove:
            query  = "DELETE FROM packages WHERE p_record = %d" % rnum
            result = db_doquery(query)
            query  = "DELETE FROM requires WHERE record = %d" % rnum
            result = db_doquery(query)
            query  = "DELETE FROM provides WHERE record = %d" % rnum
            result = db_doquery(query)
            query  = "DELETE FROM files WHERE record = %d" % rnum
            result = db_doquery(query)

    if to_add:
        print_verbose('Adding tagged entries for tag: %s...' % tag)
        for rpm in to_add:
            record_add(tag, rpm)


#
# function to show database info
#
def showdbstats():
    print_debug("in showdbstats()")

    query   = "SELECT count(*) FROM tags"
    c_tags  = db_fetchone(query)
    query   = "SELECT count(*) FROM packages"
    c_pkgs  = db_fetchone(query)
    query   = "SELECT count(*) FROM requires"
    c_reqs  = db_fetchone(query)
    query   = "SELECT count(*) FROM provides"
    c_provs = db_fetchone(query)
    query   = "SELECT count(*) FROM files"
    c_files = db_fetchone(query)

    print 'Database statistics:\n'
    print '   Database => User: %s, Host: %s, Database: %s\n' % (config['username'], config['hostspec'], config['database'])
    print '   Tag records : %-15d Package records : %-15d' % (c_tags, c_pkgs)
    print '   File records: %-15d Requires records: %-15d' % (c_files, c_reqs)
    print '                                 Provides records: %-15d\n' % c_provs
    exit(0)


#
# function to show progress
#
def show_progress(prefix=False):
    global pstate

    if not options.verbose and not options.debug and options.progress:
        if not prefix:
            if pstate == 1:
                sys.stdout.write('.')
            pstate = pstate + 1
            if pstate > 20:
                pstate = 1
            return

        if prefix != 'files' and prefix != 'sources' and prefix != '':
            sys.stdout.write("%s: " % prefix.strip())
            pstate = 1
            return
        elif prefix != lprefix:
            sys.stdout.write('\t%s: ' %prefix)
            lprefix = prefix
            return


#
# function to check for existence of tags
#
def tag_check(tag, file):
    print_debug('in tag_check(%s, %s)' % (tag, file))

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    query = "SELECT path FROM tags WHERE tag = '%s' LIMIT 1" % tag
    result = db_fetchone(query)
    if result:
        print_debug('Tag (%s) already exists in the database with path: %s' % (tag, result))
        return True
    else:
        print_debug('Tag or path does NOT exist in the database')
        return False

#        if len(result) > 0:
#            if result[1] != path:
#                #print 'Tag (%s) is already in the database with path: %s\n' % (tag, result[1])
#                #exit(1)
#                return(True)
#            else:
#                return(False)
#    except:
#        return(False)


#
# function to add a tag record
#
def tag_add_record(tag, file):
    print_debug('in tag_add_record(%s, %s)' % (tag, file))

    cur_date = datetime.datetime.now()
    cur_date = cur_date.strftime('%a %b %d %H:%M:%S %Y')

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    # we can have multiple similar paths, but not multiple similar tags
    query  = "SELECT tag FROM tags WHERE tag = '%s'" % tag
    result = db_fetchone(query)
    if result:
        print 'Tag already exists in the database!\n'
        db_close()
        exit(1)

    query = "INSERT INTO tags (tag, path, tdate) VALUES ('%s', '%s', '%s')" % (tag.strip(), path.strip(), cur_date)
    db_doquery(query)
    return(0)


#
# function to add a record to the database
#
def record_add(tag, file):
    print_debug('in record_add(%s, %s)' % (tag, file))

    # corrupts add data -- not needed
    if options.verbose:
        verbose = False

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    print_debug('Path:\t%s' % path)

    file_rpm_check(file, 'binary')

    record = package_add_record(tag, file)
    if not record:
        return

    print_debug('Add file records for package record: %s' % record)
    add_file_records(record, file)
    add_file_requires(record, file)
    add_file_provides(record, file)
    if options.progress:
        sys.stdout.write('\n')


#
# function to add requires to the database
#
def add_file_requires(record, file):
    print_debug('in add_file_requires(%s, %s)' % (record, file))

    list = commands.getoutput("rpm -qp --nosignature --requires " + file + " | egrep -v '(rpmlib|GLIBC|GCC|rtld)' | uniq")
    list = list.splitlines()
    for dep in list:
        if dep:
            show_progress()
            if options.verbose:
                print 'Dependency: %s' % dep
            query  = "INSERT INTO requires (record, requires) VALUES ('%s', '%s')" % (record, dep.strip())
            result = db_doquery(query)


#
# function to add provides to the database
#
def add_file_provides(record, file):
    print_debug('in add_file_provides(%s, %s)' % (record, file))

    list = commands.getoutput("rpm -qp --nosignature --provides " + file)
    list = list.splitlines()
    for prov in list:
        if prov:
            show_progress()
            if options.verbose:
                print 'Provides: %s' % prov
            query  = "INSERT INTO provides (record, provides) VALUES ('%s', '%s')" % (record, prov.strip())
            result = db_doquery(query)


#
# function to get the list of files in an rpm
#
def rpm_list(file):
    print_debug('in rpm_list(%s)' % file)

    list = commands.getoutput("rpm -qlp --nosignature " + file)
    list = list.splitlines()
    return(list)


#
# function to import a directory full of rpms
#
def rpm_add_directory(tag, path, type='binary'):
    print_debug('in rpm_add_directory(%s, %s)' % (tag, path))

    new_tag = tag_add_record(tag, path)
    if new_tag:
        exit(1)

    file_list = glob(path + "/*.rpm")
    for file in file_list:
        if not os.path.isfile(file):
            print 'File %s not found!\n' % file
            next

        if type == 'binary':
            if not re_brpm.search(file) or re_srpm.search(file):
                print 'File %s is not a binary rpm!\n' % file
                next

        if type == 'source':
            if not re_srpm.search(file):
                print 'File %s is not a source rpm!\n' % file
                next

        record_add(tag, file)


#
# function to add file records
#
def add_file_records(record, file):
    print_debug('in add_file_records(%s, %s)' % (record, file))

    file_list = rpm_list(file)

    for single_file in file_list:
        show_progress()
        if options.verbose:
            print 'File: %s' % single_file
        query  = "INSERT INTO files (record, files) VALUES ('%s', '%s')" % (record, single_file.strip())
        result = db_doquery(query)


#
# function to add a package record
#
def package_add_record(tag, file):
    print_debug('in package_add_record(%s, %s)' % (tag, file))

    path    = os.path.basename(file)
    rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}' " + file)
    tlist   = rtags.split('|')
    package = tlist[0].strip()
    version = tlist[1].strip()
    release = tlist[2].strip()
    pdate   = tlist[3].strip()

    query = "SELECT p_tag, p_package, p_version, p_release FROM packages WHERE p_tag = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (tag, package, version, release)
    result = db_fetchall(query)
    if result:
        print 'File %s-%s-%s is already in the database under tag %s' % (package, version, release, tag)
        return(0)

    query  = "INSERT INTO packages (p_tag, p_package, p_version, p_release, p_date) VALUES ('%s', '%s', '%s', '%s', '%s')" % (tag, package, version, release, pdate)
    result = db_doquery(query)
    show_progress(path)

    query  = "SELECT p_record FROM packages WHERE p_tag = '%s' AND p_package = '%s' ORDER BY p_record DESC" % (tag, package)
    result = db_fetchone(query)
    if result:
            return(result)
    else:
        print 'Adding file %s failed!\n' % file
        return(0)


#
# function to check whether the file is a source or binary rpm
# defaults to binary
#
def file_rpm_check(file, type='binary'):
    print_debug('in file_check(%s, %s)' % (file, type))

    if not os.path.isfile(file):
        print 'File %s not found!\n' % file
        exit(1)

    if type == 'binary':
        if not re_brpm.search(file) or re_srpm.search(file):
            print 'File %s is not a binary rpm!\n' % file
            exit(1)

    if type == 'source':
        if not re_srpm.search(file):
            print 'File %s is not a source rpm!\n' % file
            exit(1)


#
# function to run the query
#
def run_query(qstring, type):
    print_debug('in run_query(%s, %s)' % (qstring, type))

    if not options.quiet:
        print 'Searching database records for substring match for %s (%s)' % (type, qstring)

    query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s FROM %s LEFT JOIN packages ON (packages.p_record = %s.record) WHERE %s " % (type, type, type, type)

    if options.ignorecase:
        query = query + "LIKE '%" + qstring + "%'"
    else:
        query = query + "LIKE '%" + qstring + "%'"

    if options.tag:
        query = query + " AND p_tag = '" + options.tag + "'"

    query  = query + " ORDER BY p_tag, p_package, " + type
    result = db_fetchall(query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring (%s)' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring (%s)' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag  = row[0]
            fromdb_rpm  = row[1]
            fromdb_ver  = row[2]
            fromdb_rel  = row[3]
            fromdb_date = row[4]
            fromdb_file = row[5]

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                rpm = fromdb_rpm

                if not rpm == lsrc:
                    print '%s: %s' % (rpm, fromdb_file)

                if options.quiet:
                    lsrc = rpm
                else:
                    if options.extrainfo:
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", fromdb_file)
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)
                    #print '%-16s%-30s' % (type.title(), row[5])

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring (%s)' % (options.tag, qstring)
        else:
            print 'No matches in database for substring (%s)' % qstring


#
# the main program
#
if __name__ == '__main__':
    global options, config

    rq_version = '0.2'

    sys.stdout.write("rqp %s ($Id$)\n\n" % rq_version)

    p = optparse.OptionParser(description="RPM package query tool",
                              prog="rqp",
                              version="%prog " + rq_version,
                              usage="%prog [-h] [-v] [-c <directory>] [-[q|r|p] <substring>] [-t <tag>]")
    p.add_option('-C', '--count', dest="count", default=False, action="store_true", help="Only output the count of query matches")
    p.add_option('-d', '--debug', dest="debug", default=False, action="store_true", help="Enable debugging output")
    p.add_option('-e', '--extrainfo', dest="extrainfo", default=False, action="store_true", help="Show extra info (version, release, date)")
    p.add_option('-i', '--ignorecase', dest="ignorecase", default=False, action="store_true", help="Case insensitive search")
    p.add_option('-l', '--list', dest="list", default=False, action="store_true", help="List database tags")
    p.add_option('-P', '--progress', dest="progress", default=False, action="store_true", help="Show processing progress")
    p.add_option('-Q', '--quiet', dest="quiet", default=False, action="store_true", help="Quiet query - show tag and package name only (or numeric count only)")
    p.add_option('-x', '--statistics', dest="stats", default=False, action="store_true", help="Show database statistics")
    p.add_option('-v', '--verbose', dest="verbose", default=False, action="store_true", help="Verbose output")
    dbgroup = optparse.OptionGroup(p, "Database Options")
    dbgroup.add_option('-a', '--add', dest="addfile", help="Add a binary rpm entry with TAG to the database", metavar="FILE")
    dbgroup.add_option('-c', '--createpath', dest="createpath", help="Create database entries with TAG from a binary rpm DIR", metavar="DIR")
    dbgroup.add_option('-D', '--delete', dest="tagdelete", help="Delete all TAG entries", metavar="TAG")
    dbgroup.add_option('-t', '--tag', dest="tag", help="TAG for created database entries or database queries", metavar="TAG")
    dbgroup.add_option('-u', '--update', dest="tagupdate", help="Update TAG entries (new/removed files in directory)", metavar="TAG")
    p.add_option_group(dbgroup)
    group = optparse.OptionGroup(p, "Query Options")
    group.add_option('-p', '--provides', dest="provides", help="Query database for substring match on provides", metavar="STRING")
    group.add_option('-q', '--query', dest="query", help="Query database for substring match on files", metavar="STRING")
    group.add_option('-r', '--requires', dest="requires", help="Query database for substring match on requires", metavar="STRING")
    p.add_option_group(group)
    (options, arguments) = p.parse_args()

    if len(sys.argv) == 1:      # no arguments passed
        p.print_help()
    if len(arguments) == 1:
        p.print_help()

    # setup the options
    if options.provides and options.query:
        p.error("--provides and --query are mutually exclusive")
    if options.provides and options.requires:
        p.error("--provides and --requires are mutually exclusive")
    if options.query and options.requires:
        p.error("--query and --provides are mutually exclusive")
    if options.provides and options.query and options.requires:
        p.error("--query, --provides, and --requires are mutually exclusive")
    if options.verbose and options.quiet:
        p.error("--quiet and --verbose are mutually exclusive")
    if options.tag and options.tagdelete:
        p.error("--tag and --delete are mutually exclusive; you do not need to use --tag")

    if options.debug:
        print_debug("debug mode enabled")

    if options.verbose:
        print_verbose("Verbose mode enabled")

    config = {}

    config_file = '/etc/rqrc'
    if os.path.isfile(config_file):             # look for a system-wide one first
        config = read_config(config_file)

    config_file = os.getenv('HOME') + '/.rqrc'
    if os.path.isfile(config_file):             # if we find a local one, overwrite anything defined
        config = read_config(config_file)

    if not config:
        sys.stderr.write('\n\nERROR: No configuration file found!\n')
        exit(1)

    db = db_connect('binary')

    # start doing useful things
    if options.list:
        tag_list()

    if options.stats:
        showdbstats()

    if options.tag:
        print_debug('Tag:\t%s\n' % options.tag)

    if options.tagdelete:
        tag_delete_entries(options.tagdelete)
        exit(0)

    if options.tagupdate:
        tag_update_entries(options.tagupdate)
        exit(0)

    if options.query:
        run_query(options.query, 'files')
        exit(0)

    if options.provides:
        run_query(options.provides, 'provides')
        exit(0)

    if options.requires:
        run_query(options.requires, 'requires')
        exit(0)

    # this option is strange... it must be for adding a file, but should a single file
    # have a new tag?  or can we add it (despite the path) to an existing tag?
    # XXX: it also needs to be able to support numerous files at once
    # XXX: TODO
    if options.addfile:
        if not options.tag:
            sys.stdout.write('The --add option requires a tag entry!\n')
            exit(1)

        havetag = tag_check(options.tag, options.addfile)
        print_debug('havetag is: %s' % havetag)

        if not havetag:
            tag_add_record(options.tag, options.addfile)

        record_add(options.tag, options.addfile)
        exit(0)

    if options.createpath:
        createpath = os.path.abspath(options.createpath)
        print_debug('Dir:\t%s' % createpath)
        if not options.tag:
            sys.stdout.write('The --create option requires a tag entry!\n')
            exit(1)

        sys.stdout.write('Searching for rpms to import...\n\n')
        rpm_add_directory(options.tag, createpath, 'binary')
        exit(0)
