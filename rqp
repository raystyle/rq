#!/usr/bin/env python
"""
This program extracts data from RPM and SRPM packages and stores it in
a database for later querying.

based on the srpm script of similar function copyright (c) 2005 Stew Benedict <sbenedict@mandriva.com>
copyright (c) 2007-2009 Vincent Danen <vdanen@linsec.ca>

$Id$
"""

import optparse, os, sys, re, datetime, commands, shutil, tempfile, logging
#import MySQLdb, MySQLdb.cursors
import rqdb
from glob import glob
#import MySQLdb.connect

re_srpm    = re.compile(r'\.src\.rpm$')
re_brpm    = re.compile(r'\.rpm$')
re_patch   = re.compile(r'\.(diff|dif|patch)(\.bz2|\.gz)?$')
re_tar     = re.compile(r'\.((tar)(\.bz2|\.gz)?|t(gz|bz2?))$')
re_targz   = re.compile(r'\.(tgz|tar\.gz)$')
re_tarbz   = re.compile(r'\.(tbz2?|tar\.bz2)$')
re_patchgz = re.compile(r'\.(patch|diff|dif)(\.gz)$')
re_patchbz = re.compile(r'\.(patch|diff|dif)(\.bz2)$')

file_excludes = ('.svn', 'CVS', 'AUTHORS', 'Makefile', 'ChangeLog', 'COPYING', 'TODO', 'README')

def sanitize_string(string):
    """
    String to cleanup a string to remove characters that will cause problems
    with the database
    """
    #logging.debug('  in sanitize_string(%s)' % string)
    if string:
        # escape single and double quotes
        new_string = re.sub('''(['";\\\])''', r'\\\1', string)
    else:
        new_string = None
    return(new_string)


def read_config(config_file):
    """
    Function to read the configuration file
    """
    logging.debug("in read_config(%s)" % config_file)

    config = {}
    for line in open(config_file):
        line = line.rstrip()
        if not line:                                        # ignore empties
            continue
        if line.startswith("#") or line.startswith(";"):    # and ignore comments
            continue

        # Split on the first "=", this allows for values to have a "=" in them
        (config_name, config_value) = line.split("=", 1)
        config_name                 = config_name.strip()
        config[config_name]         = config_value

    return config


def tag_list():
    """
    Function to show database tags
    """
    logging.debug("in tag_list()")

    query   = 'SELECT tag, path, tdate FROM tags ORDER BY tag'
    results = rqdb.fetch_all(db, query)
    if results:
        for row in results:
            print 'Tag: %-22sDate Added: %-18s\n  Path: %s\n' % (row['tag'], row['tdate'], row['path'])
    else:
        print 'No tags exist in the database!\n'

    rqdb.close(db)
    sys.exit(0)


def tag_delete_entries(tag, type='binary'):
    """
    Function to delete database tags and associated entries
    """
    logging.debug('in tag_delete_entries(%s)' % tag)

    tag_id =  tag_lookup_id(tag)

    if not tag_id:
        print 'No matching tag found for entry %s!\n' % tag
        sys.exit(1)
    else:
        print 'Removing tag (%s) from Tags...\n' % tag
        query = "DELETE FROM tags WHERE t_record = '%s'" % tag_id
        rqdb.do_query(db, query)

        query  = "SELECT count(*) FROM packages WHERE t_record = '%s'" % tag_id
        result = rqdb.fetch_one(db, query)
        if result:
            if result == 1:
                word_package = 'Package'
                word_entry   = 'entry'
            else:
                word_package = 'Packages'
                word_entry   = 'entries'

            sys.stdout.write('Removing %s tagged %s %s for %s... ' % (result, word_package, word_entry, tag))
            sys.stdout.flush()

            if type == 'binary':
                tables = ('packages', 'requires', 'provides', 'files')
            if type == 'source':
                tables = ('packages', 'sources', 'files', 'ctags')

            for table in tables:
                query = "DELETE FROM %s WHERE t_record = '%s'" % (table, tag_id)
                res   = rqdb.do_query(db, query)

            sys.stdout.write(' done\n')

            sys.stdout.write('Optimizing database (this may take some time)... ')
            sys.stdout.flush()
            for table in tables:
                query = 'OPTIMIZE TABLE %s' % table
                res   = rqdb.do_query(db, query)
            sys.stdout.write(' done\n')
        else:
            sys.stdout.write('No matching package tags to remove.\n')


def tag_update_entries(tag, type='binary'):
    """
    function to update entries for a given tag
    """
    logging.debug('in tag_update_entries(%s)' % tag)
    #
    # this function is designed for src.rpm handling, but we can update it for binary rpm handling too
    # XXX: TODO
    #

    to_remove = []
    to_add    = []

    query  = "SELECT DISTINCT path FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    path   = rqdb.fetch_one(db, query)
    query  = "SELECT DISTINCT t_record FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    tag_id = rqdb.fetch_one(db, query)

    if path:
        logging.info('Update tag (%s) entries from %s...' % (tag, path))
        # get the existing entries
        query  = "SELECT DISTINCT p_record, p_tag, p_package, p_version, p_release FROM packages WHERE t_record = '%s'" % tag_id
        result = rqdb.fetch_all(db, query)
        for row in result:
            pname = '%s-%s-%s.src.rpm' % (row['p_package'], row['p_version'], row['p_release'])
            logging.info('Checking for %s in %s...' % (pname, path))
            if os.path.isfile(pname):
                logging.info('OK')
            else:
                logging.info('Missing')
                to_remove.append(result['p_record'])

        src_list = glob(path + "/*.rpm")
        src_list.sort()

        for src_rpm in src_list:
            logging.info('Checking for %s in database...' % src_rpm)
            rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}' " + src_rpm.replace(' ', '\ '))
            tlist   = rtags.split('|')
            package = tlist[0].strip()
            version = tlist[1].strip()
            release = tlist[2].strip()

            query   = "SELECT p_package FROM packages WHERE t_record = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (tag_id, sanitize_string(package), sanitize_string(version), sanitize_string(release))
            package = rqdb.fetch_one(db, query)
            if package:
                logging.info('OK')
            else:
                logging.info('Adding')
                to_add.append(src_rpm)
    else:
        sys.stdout.write('No Tag entry found for tag: %s\n' % tag)

    if to_remove:
        logging.info('Removing tagged entries for tag: %s...' % tag)
        if type == 'binary':
            tables = ('packages', 'requires', 'provides', 'files')
        if type == 'source':
            tables = ('packages', 'sources')
        for rnum in to_remove:
            for table in tables:
                query  = "DELETE FROM %s WHERE p_record = %d" % (table, rnum)
                result = rqdb.do_query(db, query)

    if to_add:
        logging.info('Adding tagged entries for tag: %s...' % tag)
        for rpm in to_add:
            record_add(tag_id, rpm, type)


def showdbstats(type, tag):
    """
    Function to show database info
    """
    logging.debug("in showdbstats(%s, %s)" % (type, tag))

    if tag == 'all':
        extra_opts = ''
    else:
        tag_id = tag_lookup_id(tag)
        if tag_id:
            extra_opts = "WHERE t_record = '%d'" % tag_id
        else:
            print 'No such tag: "%s" does not exist in the database!\n' % tag
            sys.exit(1)

    query   = "SELECT count(*) FROM tags %s" % extra_opts
    c_tags  = rqdb.fetch_one(db, query)
    query   = "SELECT count(*) FROM packages %s" % extra_opts
    c_pkgs  = rqdb.fetch_one(db, query)
    if type == 'binary':
        query   = "SELECT count(*) FROM requires %s" % extra_opts
        c_reqs  = rqdb.fetch_one(db, query)
        query   = "SELECT count(*) FROM provides %s" % extra_opts
        c_provs = rqdb.fetch_one(db, query)
    else:
        query   = "SELECT count(*) FROM sources %s" % extra_opts
        c_src   = rqdb.fetch_one(db, query)
        query   = "SELECT count(*) FROM ctags %s" % extra_opts
        c_ctags = rqdb.fetch_one(db, query)
    query   = "SELECT count(*) FROM files %s" % extra_opts
    c_files = rqdb.fetch_one(db, query)

    # get the size of the database as well
    size   = 0.00
    bytes  = ''
    query  = "SHOW TABLE STATUS"
    tbsize = rqdb.fetch_all(db, query)

    for x in tbsize:
        size += x['Data_length']
    count = 0

    while size > 1024:
        size   = size / 1024
        count += 1
        if count == 1:
            bytes = 'KB'
        if count == 2:
            bytes = 'MB'
        if count == 3:
            bytes = 'GB'
            break

    print 'Database statistics:\n'
    if tag != 'all':
        print 'Printing statistics for tag: %s\n' % tag
    print '   Database  => User: %s, Host: %s, Database: %s' % (config['username'], config['hostspec'], config['database'])
    print '   Data size => %2.2f %s\n' % (size, bytes)
    print '   Tag records  : %-16d Package records : %-15d' % (c_tags, c_pkgs)
    if type == 'binary':
        print '   File records : %-15d  Requires records: %-15d' % (c_files, c_reqs)
        print '                                   Provides records: %-15d\n' % c_provs
    else:
        print '   File records : %-15d  Source records  : %-15d' % (c_files, c_src)
        print '   Ctags records: %-15d' % (c_ctags)
    sys.exit(0)


def show_progress(prefix=False):
    """
    Function to show progress
    """
    global pstate

    if not options.verbose and not options.debug and options.progress:
        if not prefix:
            if pstate == 1:
                sys.stdout.write('.')
                sys.stdout.flush()
            pstate = pstate + 1
            if pstate > 150:
                pstate = 1
            return

        if prefix != 'files' and prefix != 'sources' and prefix != '':
            sys.stdout.write("%s: " % prefix.strip())
            sys.stdout.flush()
            pstate = 1
            return
        elif prefix != lprefix:
            sys.stdout.write('\t%s: ' %prefix)
            sys.stdout.flush()
            lprefix = prefix
            return


def tag_lookup(tag):
    """
    Function to see if a tag exists
    """
    logging.debug('in tag_lookup(%s)' % tag)

    query = "SELECT path FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    path  = rqdb.fetch_one(db, query)
    if path:
        return(path)
    else:
        return False


def tag_lookup_id(tag):
    """
    Function to return the t_record ID of a tag
    """
    logging.debug('in tag_lookup_id(%s)' % tag)

    query     = "SELECT t_record FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    t_record  = rqdb.fetch_one(db, query)
    if t_record:
        return(t_record)
    else:
        return False


def tag_check(tag, file):
    """
    Function to check for the existence of tags
    """
    logging.debug('in tag_check(%s, %s)' % (tag, file))

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)

    tpath = tag_lookup(tag)

    if tpath:
        logging.debug('Tag (%s) already exists in the database with path: %s' % (tag, tpath))
        return True
    else:
        logging.debug('Tag or path does NOT exist in the database')
        return False

#        if len(result) > 0:
#            if result[1] != path:
#                #print 'Tag (%s) is already in the database with path: %s\n' % (tag, result[1])
#                #sys.exit(1)
#                return(True)
#            else:
#                return(False)
#    except:
#        return(False)


def tag_add_record(tag, file):
    """
    Function to add a tag record, returns the ID of the newly created tag
    """
    logging.debug('in tag_add_record(%s, %s)' % (tag, file))

    cur_date = datetime.datetime.now()
    cur_date = cur_date.strftime('%a %b %d %H:%M:%S %Y')

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    # we can have multiple similar paths, but not multiple similar tags
    query = "SELECT tag FROM tags WHERE tag = '%s'" % sanitize_string(tag)
    dbtag = rqdb.fetch_one(db, query)
    if dbtag:
        print 'Tag (%s) already exists in the database!\n' % tag
        sys.exit(1)

    query = "INSERT INTO tags (t_record, tag, path, tdate) VALUES (NULL,'%s', '%s', '%s')" % (sanitize_string(tag.strip()), sanitize_string(path.strip()), cur_date)
    rqdb.do_query(db, query)

    query   = "SELECT t_record FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    tag_id  = rqdb.fetch_one(db, query)
    if tag_id:
        return(tag_id)
    else:
        return(0)


def record_add(tag_id, file, type):
    """
    Function to add a record to the database
    """
    logging.debug('in record_add(%s, %s, %s)' % (tag_id, file, type))

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    logging.debug('Path:\t%s' % path)

    file_rpm_check(file, type)

    record = package_add_record(tag_id, file, type)
    if not record:
        return

    file_list = rpm_list(file)
    if not file_list:
        return

    if type == 'binary':
        logging.debug('Add file records for package record: %s' % record)
        add_file_records(tag_id, record, file_list)
        add_file_requires(tag_id, record, file)
        add_file_provides(tag_id, record, file)

    if type == 'source':
        logging.debug('Add source records for package record: %s' % record)
        add_source_records(tag_id, record, file_list)
        cpio_dir = tempfile.mkdtemp()

        try:
            current_dir = os.getcwd()
            os.chdir(cpio_dir)
            source_get_all_files(file)
            add_source_file_records(tag_id, record, file_list)
            add_source_ctag_records(tag_id, record, cpio_dir)
            os.chdir(current_dir)
        finally:
            logging.debug('Removing temporary directory: %s...' % cpio_dir)
            shutil.rmtree(cpio_dir)

    if options.progress:
        sys.stdout.write('\n')


def source_get_all_files(file):
    """
    Function to get the source and patch files from a SRPM
    """
    logging.debug('in source_get_all_files(%s)' % file)
    source_get_tar_files(file)
    source_get_patch_files(file)


def source_get_tar_files(file):
    """
    Function to get the tar files from a SRPM

    cpio --quiet is a GNU-ism and isn't portable
    """
    logging.debug('in source_get_tar_files(%s)' % file)

    exts = ['*.tar.?z*', '*.tgz', '*.tbz', '*.zip']
    for search in exts:
        command      = 'rpm2cpio "%s" | cpio -i "%s" 2>/dev/null' % (file, search)
        (rc, output) = commands.getstatusoutput(command)
        logging.debug('called cpio (rc=%s): %s' % (rc, command))

#    if not rc == 0:
#        logging.critical('Failed to execute rpm2cpio!  Command was: %s\nOutput was:\n(rc: %s) %s\n' % (command, rc, output))
#        sys.exit(1)


def source_get_patch_files(file):
    """
    Function to get the patch files from a SRPM
    """
    logging.debug('in source_get_patch_files(%s)' % file)

    exts = ['*patch*', '*diff*']
    for search in exts:
        command      = 'rpm2cpio "%s" | cpio -i "%s" 2>/dev/null' % (file, search)
        (rc, output) = commands.getstatusoutput(command)
        logging.debug('called cpio (rc=%s): %s' % (rc, output))

#    if not rc == 0:
#        logging.critical('Failed to execute rpm2cpio!  Command was: %s\nOutput was:\n(rc: %s) %s\n' % (command, rc, output))
#        sys.exit(1)


def add_file_requires(tag_id, record, file):
    """
    Function to add requires to the database
    """
    logging.debug('in add_file_requires(%s, %s, %s)' % (tag_id, record, file))

    list = commands.getoutput("rpm -qp --nosignature --requires " + file.replace(' ', '\ ') + " | egrep -v '(rpmlib|GLIBC|GCC|rtld)' | uniq")
    list = list.splitlines()
    for dep in list:
        if dep:
            show_progress()
            if options.verbose:
                print 'Dependency: %s' % dep
            query  = "INSERT INTO requires (t_record, p_record, requires) VALUES ('%s', '%s', '%s')" % (tag_id, record, sanitize_string(dep.strip()))
            result = rqdb.do_query(db, query)


def add_file_provides(tag_id, record, file):
    """
    Function to add provides to the database
    """
    logging.debug('in add_file_provides(%s, %s, %s)' % (tag_id, record, file))

    list = commands.getoutput("rpm -qp --nosignature --provides " + file.replace(' ', '\ '))
    list = list.splitlines()
    for prov in list:
        if prov:
            show_progress()
            if options.verbose:
                print 'Provides: %s' % prov
            query  = "INSERT INTO provides (t_record, p_record, provides) VALUES ('%s', '%s', '%s')" % (tag_id, record, sanitize_string(prov.strip()))
            result = rqdb.do_query(db, query)


def rpm_list(file, raw=False):
    """
    Function to get the list of files in an RPM, excluding those files defined
    by files_exclude
    """
    logging.debug('in rpm_list(%s)' % file)

    list  = commands.getoutput("rpm -qlvp --nosignature " + file.replace(' ', '\ '))

    if list == '(contains no files)' or list == '':
        return False

    if raw:
        return(list)

    list  = list.splitlines()
    rlist = {}
    count = 0

    for entry in list:
        break_loop = False
        logging.debug('processing: %s' % entry) ### DEBUG
        for exclude in file_excludes:
            # make sure we don't include any files in our exclude list
            if re.search(exclude, entry):
                logging.debug('found unwanted entry: %s' % entry)
                break_loop = True

        if break_loop:
            continue

        is_suid = 0
        is_sgid = 0
        foo     = entry.split()

        # this actually really stinks because we are allowed usernames longer
        # than 8 characters, but rpm -qlv will only display the first 8 characters
        # of the owner/group name -- not cool at all
        if len(foo[2]) > 8:
            user  = foo[2][:8]
            group = foo[2][8:]
            fname = foo[7]
        else:
            user  = foo[2]
            group = foo[3]
            fname = foo[8]
        if foo[0][3] == 's':
            is_suid = 1
        if foo[0][6] == 's':
            is_sgid = 1

        rlist[count] = {'file': fname, 'user': user, 'group': group, 'is_suid': is_suid, 'is_sgid': is_sgid}
        count       += 1

    return(rlist)


def rpm_add_directory(tag, path, type='binary'):
    """
    Function to import a directory full of RPMs
    """
    logging.debug('in rpm_add_directory(%s, %s, %s)' % (tag, path, type))

    if not os.path.isdir(path):
        print 'Path (%s) is not a valid directory!' % path
        sys.exit(1)

    if type == 'binary':
        file_list = glob(path + "/*.rpm")
        file_list.sort()

    if type == 'source':
        file_list = glob(path + "/*.src.rpm")
        file_list.sort()

    if not file_list:
        print 'No files found to import in directory: %s' % path
        sys.exit(1)

    tag_id = tag_add_record(tag, path)
    if tag_id == 0:
        logging.critical('Unable to add tag "%s" to the database!' % tag)
        sys.exit(1)

    for file in file_list:
        if not os.path.isfile(file):
            print 'File %s not found!\n' % file
            next

        if type == 'binary':
            if not re_brpm.search(file) or re_srpm.search(file):
                print 'File %s is not a binary rpm!\n' % file
                next

        if type == 'source':
            if not re_srpm.search(file):
                print 'File %s is not a source rpm!\n' % file
                next

        record_add(tag_id, file, type)


def add_file_records(tag_id, record, file_list):
    """
    Function to add file records
    """
    logging.debug('in add_file_records(%s, %s, %s)' % (tag_id, record, file_list))

    for x in file_list.keys():
        show_progress()
        if options.verbose:
            print 'File: %s' % file_list[x]['file']
        query  = "INSERT INTO files (t_record, p_record, files, f_user, f_group, f_is_suid, f_is_sgid) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d)" % (
            tag_id,
            record,
            sanitize_string(file_list[x]['file'].strip()),
            sanitize_string(file_list[x]['user']),
            sanitize_string(file_list[x]['group']),
            file_list[x]['is_suid'],
            file_list[x]['is_sgid'])
        result = rqdb.do_query(db, query)


def add_source_records(tag_id, record, file_list):
    """
    Function to add source records
    """
    logging.debug('in add_source_records(%s, %s, %s)' % (tag_id, record, file_list))

    for x in file_list.keys():
        # remove any possible paths from source files; may be due to rpm5
        sfile = file_list[x]['file'].split('/')[-1]
        logging.debug('processing source: %s ' % sfile)
        show_progress()
        stype = ''

        if re_patch.search(sfile):
            stype = 'P'
        if re_tar.search(sfile):
            stype = 'S'

        # we only care about source and patch files, nothing else
        if stype == '':
            continue

        if options.verbose:
            print 'Source: %s, Type: %s' % (sfile, stype)
        query  = "INSERT INTO sources (t_record, p_record, s_type, s_file) VALUES ('%s', '%s', '%s', '%s')" % (tag_id, record, stype, sanitize_string(sfile.strip()))
        result = rqdb.do_query(db, query)


def add_source_file_records(tag_id, record, file_list):
    """
    Function to add all source file records
    """
    logging.debug('in add_source_file_records(%s, %s, %s)' % (tag_id, record, file_list))

    for x in file_list.keys():
        good_src = False
        # file_list may contain paths, so strip them; may be due to rpm5
        sfile    = file_list[x]['file'].split('/')[-1]
        logging.debug('processing file: %s' % sfile) ### DEBUG

        if re_patch.search(sfile):
            flist    = patch_list(sfile)
            good_src = True

        if re_tar.search(sfile):
            flist    = tar_list(sfile)
            good_src = True

        # only proceed for tarballs and patches
        if good_src:
            logging.debug('found good file to process: %s' % sfile)
            files = flist.split()

            # get the s_record for this source from the db
            query   = "SELECT s_record FROM sources WHERE p_record = '%s' AND s_file = '%s'" % (record, sanitize_string(sfile))
            db_srec = rqdb.fetch_one(db, query)
            if not db_srec:
                logging.critical('adding files from %s failed...' % sfile)
                sys.exit(1)

            for dfile in files:
                if dfile.endswith('/'):     # skip directories
                    pass
                else:
                    show_progress()
                    logging.info('File: %s\n' % dfile)
                    query  = "INSERT INTO files (t_record, p_record, s_record, f_file) VALUES ('%s', '%s', '%s', '%s')" % (tag_id, record, db_srec, sanitize_string(dfile))
                    result = rqdb.do_query(db, query)
        else:
            logging.debug('unwilling to process: %s' % sfile)


def add_source_ctag_records(tag_id, record, cpio_dir):
    """
    Function to run ctags against an unpacked source directory
    and insert records into the database
    """
    logging.debug('in add_source_ctag_records(%s, %s, %s)' % (tag_id, record, cpio_dir))

    # this is likely a double chdir, but let's make sure we're in the right place
    # so we don't have to strip out the path from the ctags output
    os.chdir(cpio_dir)

    # first, identify and expand any tarballs found:
    for file in os.listdir(cpio_dir):
        if re_tar.search(file):
            # get the s_record for this source from the db
            query   = "SELECT s_record FROM sources WHERE p_record = '%s' AND s_file = '%s'" % (record, sanitize_string(file))
            db_srec = rqdb.fetch_one(db, query)
            if not db_srec:
                logging.critical('\n!!!!! adding files from %s failed...' % file)
                # don't bail, it's logged, continue
                #sys.exit(1)
                continue

            comp = 'xf'
            if re_targz.search(file):
                comp = 'xzf'
            if re_tarbz.search(file):
                comp = 'xjf'

            excludes = ''
            for f in file_excludes:
                excludes = '%s --exclude=%s' % (excludes, f)

            tmpdir  = tempfile.mkdtemp()
            command = 'tar -%s "%s" -C %s %s 2>/dev/null' % (comp, file.replace(' ', '\ '), tmpdir, excludes)

            (rc, list) = commands.getstatusoutput(command)
            logging.debug('called tar (rc=%s): %s\n%s' % (rc, command, list))

            os.chdir(tmpdir)

            # some packages contain files that are r--r--r-- which prevents
            # us from cleanly removing the directory, so do a recursive
            # chmod first
            command = "chmod -R u+w ."
            (rc, output) = commands.getstatusoutput(command)
            logging.debug('called chmod (rc=%s): %s' % (rc, command))

            command = "ctags -x -R -f - ."
            (rc, output) = commands.getstatusoutput(command)
            logging.debug('called ctags (rc=%s): %s' % (rc, command))

            for tag in output.split('\n'):
                try:
                    (name, type, line, path, extra) = tag.split(None, 4)
                except:
                    continue

                # only store some ctags info, not all of it
                wanted = ['function', 'macro', 'subroutine', 'class', 'method']
                if type in wanted:
                    show_progress()
                    query = "INSERT INTO ctags (t_record, p_record, s_record, c_name, c_type, c_line, c_file, c_extra) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')" % (
                        tag_id,
                        record,
                        db_srec,
                        sanitize_string(name),
                        sanitize_string(type),
                        sanitize_string(line),
                        sanitize_string(path),
                        sanitize_string(extra))
                    result = rqdb.do_query(db, query)
                    #print '%s\n' % query
            os.chdir(cpio_dir)
            shutil.rmtree(tmpdir)


def patch_list(file):
    """
    Function to get a list of files that a patch touches
    """
    logging.debug('in patch_list(%s)' % file)

    grep = 'grep'

    if re_patchgz.search(file):
        grep = 'zgrep'

    if re_patchbz.search(file):
        grep = 'bzgrep'

    list = commands.getoutput(grep + " '^+++' " + file.replace(' ', '\ ') + " 2>/dev/null | awk '{print $2}'")

    return(list)


def tar_list(file):
    """
    Function to get a list of files in a tarball
    """
    logging.debug('in tar_list(%s)' % file)

    comp = 'tf'
    if re_targz.search(file):
        comp = 'tzf'
    if re_tarbz.search(file):
        comp = 'tjf'

    excludes = ''
    for f in file_excludes:
        excludes = '%s --exclude=%s' % (excludes, f)

    command = 'tar -%s "%s" %s 2>/dev/null' % (comp, file.replace(' ', '\ '), excludes)

    (rc, list) = commands.getstatusoutput(command)
    logging.debug('called tar (rc=%s): %s\n%s' % (rc, command, list))

    return(list)


def package_add_record(tag_id, file, type):
    """
    Function to add a package record
    """
    logging.debug('in package_add_record(%s, %s)' % (tag_id, file))

    path    = os.path.basename(file)
    if type == 'binary':
        rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}|%{ARCH}' " + file.replace(' ', '\ '))
    else:
        rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}' " + file.replace(' ', '\ '))
    tlist   = rtags.split('|')
    logging.debug("tlist is %s " % tlist)
    package = tlist[0].strip()
    version = tlist[1].strip()
    release = tlist[2].strip()
    pdate   = tlist[3].strip()
    if type == 'binary':
        arch    = tlist[4].strip()

    query = "SELECT tag FROM tags WHERE t_record = '%s' LIMIT 1" % tag_id
    tag   = rqdb.fetch_one(db, query)

    if type == 'binary':
        query = "SELECT t_record, p_package, p_version, p_release, p_arch FROM packages WHERE t_record = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s' AND p_arch = '%s'" % (
            tag_id,
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release),
            sanitize_string(arch))
    else:
        query = "SELECT t_record, p_package, p_version, p_release FROM packages WHERE t_record = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (
            tag_id,
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release))
    result = rqdb.fetch_all(db, query)
    if result:
        if type == 'binary':
            print 'File %s-%s-%s.%s is already in the database under tag %s' % (package, version, release, arch, tag)
        else:
            print 'File %s-%s-%s is already in the database under tag %s' % (package, version, release, tag)
        return(0)

    ## TODO: we shouldn't have to have p_tag here as t_record has the same info, but it
    ## sure makes it easier to sort alphabetically and I'm too lazy for the JOINs right now

    if type == 'binary':
        query  = "INSERT INTO packages (t_record, p_tag, p_package, p_version, p_release, p_date, p_arch) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s')" % (
            tag_id,
            sanitize_string(tag),
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release),
            sanitize_string(pdate),
            sanitize_string(arch))
    else:
        query  = "INSERT INTO packages (t_record, p_tag, p_package, p_version, p_release, p_date) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')" % (
            tag_id,
            sanitize_string(tag),
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release),
            sanitize_string(pdate))
    result = rqdb.do_query(db, query)
    show_progress(path)

    query    = "SELECT p_record FROM packages WHERE t_record = '%s' AND p_package = '%s' ORDER BY p_record DESC" % (tag_id, sanitize_string(package))
    p_record = rqdb.fetch_one(db, query)
    if p_record:
            return(p_record)
    else:
        print 'Adding file %s failed!\n' % file
        return(0)


def file_rpm_check(file, type='binary'):
    """
    Function to check whether the file is a source or binary RPM

    The default is binary
    """
    logging.debug('in file_rpm_check(%s, %s)' % (file, type))

    if not os.path.isfile(file):
        print 'File %s not found!\n' % file
        sys.exit(1)

    if type == 'binary':
        if not re_brpm.search(file) or re_srpm.search(file):
            print 'File %s is not a binary rpm!\n' % file
            sys.exit(1)

    if type == 'source':
        if not re_srpm.search(file):
            print 'File %s is not a source rpm!\n' % file
            sys.exit(1)


def run_binary_query(qstring, type):
    """
    Function to run the query for binary RPMs
    """
    logging.debug('in run_binary_query(%s, %s)' % (qstring, type))

    if options.tag and not tag_lookup(options.tag):
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)

    tag_id =  tag_lookup_id(options.tag)

    if not options.quiet:
        print 'Searching database records for substring match for %s (%s)' % (type, qstring)

    if options.ignorecase:
        ignorecase = ''
    else:
        ignorecase = 'BINARY'

    if type == 'files' and options.ownership:
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s, f_user, f_group, f_is_suid, f_is_sgid FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s %s " % (
            type, type, type, ignorecase, type)
    else:
        # query on type: provides, requires, symbols
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s %s " % (
            type, type, type, ignorecase, type)

    query = query + "LIKE '%" + sanitize_string(qstring) + "%'"

    if options.tag:
        query = "%s AND %s.t_record = '%d'"  % (query, type, tag_id)

    query  = query + " ORDER BY p_tag, p_package, " + type
    result = rqdb.fetch_all(db, query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring (%s)' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring (%s)' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag  = row['p_tag']
            fromdb_rpm  = row['p_package']
            fromdb_ver  = row['p_version']
            fromdb_rel  = row['p_release']
            fromdb_date = row['p_date']
            fromdb_file = row[type]

            if type == 'files' and options.ownership:
                fromdb_user    = row['f_user']
                fromdb_group   = row['f_group']
                fromdb_is_suid = row['f_is_suid']
                fromdb_is_sgid = row['f_is_sgid']

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s\n' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                rpm = fromdb_rpm

                if not rpm == lsrc:
                    if type == 'files' and options.ownership:
                        is_suid = ''
                        is_sgid = ''
                        if fromdb_is_suid == 1:
                            is_suid = '*'
                        if fromdb_is_sgid == 1:
                            is_sgid = '*'
                        print '%s: %s (%s%s, %s%s)' % (rpm, fromdb_file, is_suid, fromdb_user, is_sgid, fromdb_group)
                    else:
                        print '%s: %s' % (rpm, fromdb_file)

                if options.quiet:
                    lsrc = rpm
                else:
                    if options.extrainfo:
                        rpm_date = datetime.datetime.fromtimestamp(float(fromdb_date))
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", rpm_date.strftime('%a %b %d %H:%M:%S %Y'))
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring (%s)' % (options.tag, qstring)
        else:
            print 'No matches in database for substring (%s)' % qstring


def run_source_query(qstring, type):
    """
    Function to run the query for source RPMs
    """
    logging.debug('in run_source_query(%s)' % qstring)

    if options.tag and not tag_lookup(options.tag):
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)

    if not options.quiet:
        print 'Searching database records for substring match (%s)' % qstring

    if options.ignorecase:
        ignorecase = ''
    else:
        ignorecase = 'BINARY'

    if type == 'ctags':
        query   = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, s_type, s_file, c_file, c_type, c_extra, c_line FROM ctags JOIN sources ON (sources.s_record = ctags.s_record) JOIN packages ON (packages.p_record = ctags.p_record) WHERE %s c_name " % ignorecase
        orderby = "c_file"
    else:
        query   = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, s_type, s_file, f_file FROM files JOIN sources ON (sources.s_record = files.s_record) JOIN packages ON (packages.p_record = files.p_record) WHERE %s f_file " % ignorecase
        orderby = "f_file"

    query = query + "LIKE '%" + sanitize_string(qstring) + "%'"

    if options.sourceonly:
        query = query + " AND s_type = 'S'"

    if options.tag:
        query = query + " AND p_tag = '" + sanitize_string(options.tag) + "'"

    query  = "%s ORDER BY p_tag, p_package, s_type, s_file, %s" % (query, orderby)
    result = rqdb.fetch_all(db, query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring (%s)' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring (%s)' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag   = row['p_tag']
            fromdb_rpm   = row['p_package']
            fromdb_ver   = row['p_version']
            fromdb_rel   = row['p_release']
            fromdb_date  = row['p_date']
            fromdb_type  = row['s_type']
            fromdb_file  = row['s_file']
            fromdb_sfile = row[orderby]
            if type == 'ctags':
                fromdb_ctype  = row['c_type']
                fromdb_cline  = row['c_line']
                fromdb_cextra = row['c_extra']

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s\n' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                srpm  = '%s-%s-%s' % (fromdb_rpm, fromdb_ver, fromdb_rel)
                stype = 'source'

                if options.quiet:
                    lsrc = srpm
                    sys.stdout.write('%s\n' % srpm)
                    sys.stdout.flush()
                else:
                    if fromdb_type == 'P':
                        stype = 'patch'
                    if options.extrainfo:
                        rpm_date = datetime.datetime.fromtimestamp(float(fromdb_date))
                        print '\n%-16s%-30s' % (stype.title() + " File:", fromdb_file)
                        print '%-16s%-30s' % ("Source Path:", fromdb_sfile)
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", rpm_date.strftime('%a %b %d %H:%M:%S %Y'))
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)
                    else:
                        if type == 'ctags':
                            sys.stdout.write('%s: (%s) %s\n\tFound matching %s in %s:%s: %s\n' % (srpm, stype, fromdb_file, fromdb_ctype, fromdb_sfile, fromdb_cline, fromdb_cextra))
                        else:
                            sys.stdout.write('%s: (%s) %s: %s\n' % (srpm, stype, fromdb_file, fromdb_sfile))

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring (%s)' % (options.tag, qstring)
        else:
            print 'No matches in database for substring (%s)' % qstring


def run_source_examine(file):
    """
    Examine a src.rpm and output the details
    """
    logging.debug('in run_source_examine(%s)' % file)

    file_rpm_check(file, 'source')

    file = path = os.path.abspath(file)

    print 'Examining %s...\n' % file

    # stage 1, list the rpm content
    src_list = rpm_list(file, raw=True)
    print 'SRPM Contents:\n%s\n' % src_list

    file_list = rpm_list(file)

    cpio_dir = tempfile.mkdtemp()
    try:
        current_dir = os.getcwd()
        os.chdir(cpio_dir)

        # stage 2, list patched files
        if options.patch:
            source_get_patch_files(file)
            for x in file_list.keys():
                if re_patch.search(file_list[x]['file']):
                    plist = patch_list(file_list[x]['file'])
                    print 'Patch file %s modifies:\n%s\n' % (file_list[x]['file'], plist)

        # stage 3, list the tarball contents
        if not options.skiptar:
            source_get_tar_files(file)
            for y in file_list.keys():
                if re_tar.search(file_list[y]['file']):
                    tlist = tar_list(file_list[y]['file'])
                    print 'Tarfile %s contents:\n%s\n' % (file_list[y]['file'], tlist)

        os.chdir(current_dir)
    finally:
        logging.debug('Removing temporary directory: %s...' % cpio_dir)
        shutil.rmtree(cpio_dir)


if __name__ == '__main__':
    """
    The main program
    """
    global options, config

    rq_version = '0.2'
    if os.path.basename(sys.argv[0]) == 'rqs':
        rq_prog    = 'rqs'
        rq_type    = 'source'
    else:
        rq_prog    = 'rqp'
        rq_type    = 'binary'

    sys.stdout.write("%s %s ($Id$)\n\n" % (rq_prog, rq_version))
    # XXX: TODO add options to search files by ownership and sgid/suid status

    p = optparse.OptionParser(description="RPM package query tool",
                              prog=rq_prog,
                              version="%prog " + rq_version,
                              usage="%prog [-h] [-v] [-c <directory>] [-[q|r|p|z] <substring>] [-t <tag>]")
    p.add_option('-n', '--config', dest="conffile", help="Optional configuration file", metavar="FILE")
    p.add_option('-C', '--count', dest="count", default=False, action="store_true", help="Only output the count of query matches")
    p.add_option('-d', '--debug', dest="debug", default=False, action="store_true", help="Enable debugging output")
    p.add_option('-e', '--extrainfo', dest="extrainfo", default=False, action="store_true", help="Show extra info (version, release, date)")
    p.add_option('-i', '--ignorecase', dest="ignorecase", default=False, action="store_true", help="Case insensitive search")
    p.add_option('-l', '--list', dest="list", default=False, action="store_true", help="List database tags")
    if rq_type == 'binary':
        p.add_option('-o', '--ownership', dest="ownership", default=False, action="store_true", help="Display ownership information on files")
    if rq_type == 'source':
        p.add_option('-p', '--patch', dest="patch", default=False, action="store_true", help="List patched files when examining a src.rpm")
    p.add_option('-P', '--progress', dest="progress", default=False, action="store_true", help="Show processing progress")
    p.add_option('-Q', '--quiet', dest="quiet", default=False, action="store_true", help="Quiet query - show tag and package name only (or numeric count only)")
    if rq_type == 'source':
        p.add_option('-s', '--skip-tar', dest="skiptar", default=False, action="store_true", help="Skip tarfile extract when examining a src.rpm")
        p.add_option('-S', '--source-only', dest="sourceonly", default=False, action="store_true", help="Limit query to source files (no patches)")
    p.add_option('-T', '--suppresstag', dest="suppresstag", default=False, action="store_true", help="Suppress Tag and Path label output for queries") # was only in rqs -- why?
    p.add_option('-x', '--statistics', dest="stats", default=False, action="store_true", help="Show database statistics")
    p.add_option('-v', '--verbose', dest="verbose", default=False, action="store_true", help="Verbose output")
    dbgroup = optparse.OptionGroup(p, "Database Options")
    dbgroup.add_option('-a', '--add', dest="addfile", help="Add a " + rq_type + " rpm entry with TAG to the database", metavar="FILE")
    dbgroup.add_option('-c', '--createpath', dest="createpath", help="Create database entries with TAG from a " + rq_type + " rpm DIR", metavar="DIR")
    dbgroup.add_option('-D', '--delete', dest="tagdelete", help="Delete all TAG entries", metavar="TAG")
    if rq_type == 'source':
        dbgroup.add_option('-f', '--file', dest="src_examine", help="Examine a src.rpm FILE and output to stdout", metavar="FILE")
    dbgroup.add_option('-t', '--tag', dest="tag", help="TAG for created database entries or database queries", metavar="TAG")
    dbgroup.add_option('-u', '--update', dest="tagupdate", help="Update TAG entries (new/removed files in directory)", metavar="TAG")
    p.add_option_group(dbgroup)
    group = optparse.OptionGroup(p, "Query Options")
    if rq_type == 'binary':
        group.add_option('-p', '--provides', dest="provides", help="Query database for substring match on provides", metavar="STRING")
    group.add_option('-q', '--query', dest="query", help="Query database for substring match on files", metavar="STRING")
    if rq_type == 'binary':
        group.add_option('-r', '--requires', dest="requires", help="Query database for substring match on requires", metavar="STRING")
        group.add_option('-z', '--symbols', dest="symbols", help="Query database for substring match on symbols in binary files", metavar="STRING")
    if rq_type == 'source':
        group.add_option('-z', '--ctags', dest="ctags", help="Query database for substring match on ctags data (functions, etc.)", metavar="STRING")
    p.add_option_group(group)
    (options, arguments) = p.parse_args()       # 'arguments' is a tuple of non-optioned things

    if len(sys.argv) == 1:      # no arguments passed
        p.print_help()
        sys.exit(0)

    # setup the options
    if rq_type == 'binary':
        if options.provides and options.query:
            p.error("--provides and --query are mutually exclusive")
        if options.provides and options.requires:
            p.error("--provides and --requires are mutually exclusive")
        if options.query and options.requires:
            p.error("--query and --provides are mutually exclusive")
        if options.provides and options.query and options.requires:
            p.error("--query, --provides, and --requires are mutually exclusive")

    if options.verbose and options.quiet:
        p.error("--quiet and --verbose are mutually exclusive")
    if options.tag and options.tagdelete:
        p.error("--tag and --delete are mutually exclusive; you do not need to use --tag")

    # setup logging; default is WARNING, debug is DEBUG and verbose is INFO
    LOG_FILENAME = '%s/%s.log' % (os.getcwd(), rq_prog)
    if options.debug:
        logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG, format='%(levelname)-8s: %(message)s')

    if options.verbose:
        logging.basicConfig(filename=LOG_FILENAME,level=logging.INFO, format='%(levelname)-8s: %(message)s')

    if not options.verbose and not options.debug:
        logging.basicConfig(filename=LOG_FILENAME,level=logging.WARNING, format='%(levelname)-8s: %(message)s')

    logging.debug("debug mode enabled; type => %s" % rq_type)

    config = {}

    if options.conffile:
        if os.path.isfile(options.conffile):
            config = read_config(options.conffile)
        else:
            logging.critical('Specified configuration file does not exist: %s' % options.conffile)
            sys.exit(1)
    else:
        config_file = '/etc/rqrc'
        if os.path.isfile(config_file):             # look for a system-wide one first
            config = read_config(config_file)

        config_file = os.getenv('HOME') + '/.rqrc'
        if os.path.isfile(config_file):             # if we find a local one, overwrite anything defined
            config = read_config(config_file)

    if not config:
        logging.critical('No configuration file found!')
        sys.exit(1)

    (db, config) = rqdb.connect(rq_type, config)

    # start doing useful things
    if options.list:
        tag_list()

    if options.stats:
        if options.tag:
            showdbstats(rq_type, options.tag)
        else:
            showdbstats(rq_type, 'all')

    if options.tag:
        logging.debug('Tag:\t%s\n' % options.tag)

    if options.tagdelete:
        tag_delete_entries(options.tagdelete, rq_type)
        sys.exit(0)

    if options.tagupdate:
        tag_update_entries(options.tagupdate, rq_type)
        sys.exit(0)

    if options.query:
        if rq_type == 'binary':
            run_binary_query(options.query, 'files')
        elif rq_type == 'source':
            run_source_query(options.query, 'files')
        sys.exit(0)

    if rq_type == 'binary':
        if options.provides:
            run_binary_query(options.provides, 'provides')
            sys.exit(0)

        if options.requires:
            run_binary_query(options.requires, 'requires')
            sys.exit(0)

        if options.symbols:
            run_binary_query(options.symbols, 'symbols')

    if rq_type == 'source':
        if options.ctags:
            run_source_query(options.ctags, 'ctags')
            sys.exit(0)

        if options.src_examine:
            run_source_examine(options.src_examine)
            sys.exit(0)

    # this option is strange... it must be for adding a file, but should a single file
    # have a new tag?  or can we add it (despite the path) to an existing tag?
    # XXX: it also needs to be able to support numerous files at once
    # XXX: TODO
    if options.addfile:
        if not options.tag:
            logging.critical('The --add option requires a tag entry!')
            sys.exit(1)

        havetag = tag_check(options.tag, options.addfile)
        logging.debug('havetag is: %s' % havetag)

        if not havetag:
            logging.critical('The --add option requires an existing tag entry!')
            sys.exit(1)

        addfiles = []
        addfiles.append(options.addfile)

        if len(arguments) > 0:
            addfiles.extend(arguments)

        for afile in addfiles:
            record_add(options.tag, afile, rq_type)

        sys.exit(0)

    if options.createpath:
        createpath = os.path.abspath(options.createpath)
        logging.debug('Dir:\t%s' % createpath)
        if not options.tag:
            sys.stdout.write('The --create option requires a tag entry!\n')
            sys.exit(1)

        sys.stdout.write('Searching for rpms to import...\n\n')
        rpm_add_directory(options.tag, createpath, rq_type)
        sys.exit(0)

    # if we get here, we have completely invalid arguments
    p.print_help()
    sys.exit(0)
