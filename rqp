#!/usr/bin/env python
"""
This program extracts data from RPM and SRPM packages and stores it in
a database for later querying.

based on the srpm script of similar function copyright (c) 2005 Stew Benedict <sbenedict@mandriva.com>
copyright (c) 2007-2009 Vincent Danen <vdanen@linsec.ca>

$Id$
"""

import optparse, os, sys, re, datetime, commands, shutil, tempfile, logging
#import MySQLdb, MySQLdb.cursors
import rq.db
import rq.basics
import rq.tag
from glob import glob
#import MySQLdb.connect

re_srpm    = re.compile(r'\.src\.rpm$')
re_brpm    = re.compile(r'\.rpm$')
re_patch   = re.compile(r'\.(diff|dif|patch)(\.bz2|\.gz)?$')
re_tar     = re.compile(r'\.((tar)(\.bz2|\.gz)?|t(gz|bz2?))$')
re_targz   = re.compile(r'\.(tgz|tar\.gz)$')
re_tarbz   = re.compile(r'\.(tbz2?|tar\.bz2)$')


def record_add(tag_id, file, type):
    """
    Function to add a record to the database
    """
    logging.debug('in record_add(%s, %s, %s)' % (tag_id, file, type))

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    logging.debug('Path:\t%s' % path)

    rq.basics.file_rpm_check(file, type)

    record = package_add_record(tag_id, file, type)
    if not record:
        return

    file_list = rq.basics.rpm_list(file)
    if not file_list:
        return

    if type == 'binary':
        logging.debug('Add file records for package record: %s' % record)
        add_file_records(tag_id, record, file_list)
        add_file_requires(tag_id, record, file)
        add_file_provides(tag_id, record, file)

    if type == 'source':
        logging.debug('Add source records for package record: %s' % record)
        rqs.add_records(tag_id, record, file_list)
        cpio_dir = tempfile.mkdtemp()

        try:
            current_dir = os.getcwd()
            os.chdir(cpio_dir)
            rqs.get_all_files(file)
            rqs.add_file_records(tag_id, record, file_list)
            rqs.add_ctag_records(tag_id, record, cpio_dir)
            rqs.add_buildreq_records(tag_id, record, cpio_dir)
            os.chdir(current_dir)
        finally:
            logging.debug('Removing temporary directory: %s...' % cpio_dir)
            shutil.rmtree(cpio_dir)

    if options.progress:
        sys.stdout.write('\n')


def add_file_requires(tag_id, record, file):
    """
    Function to add requires to the database
    """
    logging.debug('in add_file_requires(%s, %s, %s)' % (tag_id, record, file))

    list = commands.getoutput("rpm -qp --nosignature --requires " + file.replace(' ', '\ ') + " | egrep -v '(rpmlib|GLIBC|GCC|rtld)' | uniq")
    list = list.splitlines()
    for dep in list:
        if dep:
            rcommon.show_progress()
            if options.verbose:
                print 'Dependency: %s' % dep
            query  = "INSERT INTO requires (t_record, p_record, requires) VALUES ('%s', '%s', '%s')" % (tag_id, record, db.sanitize_string(dep.strip()))
            result = db.do_query(query)


def add_file_provides(tag_id, record, file):
    """
    Function to add provides to the database
    """
    logging.debug('in add_file_provides(%s, %s, %s)' % (tag_id, record, file))

    list = commands.getoutput("rpm -qp --nosignature --provides " + file.replace(' ', '\ '))
    list = list.splitlines()
    for prov in list:
        if prov:
            rcommon.show_progress()
            if options.verbose:
                print 'Provides: %s' % prov
            query  = "INSERT INTO provides (t_record, p_record, provides) VALUES ('%s', '%s', '%s')" % (tag_id, record, db.sanitize_string(prov.strip()))
            result = db.do_query(query)


def rpm_add_directory(tag, path, type='binary'):
    """
    Function to import a directory full of RPMs
    """
    logging.debug('in rpm_add_directory(%s, %s, %s)' % (tag, path, type))

    if not os.path.isdir(path):
        print 'Path (%s) is not a valid directory!' % path
        sys.exit(1)

    if type == 'binary':
        file_list = glob(path + "/*.rpm")
        file_list.sort()

    if type == 'source':
        file_list = glob(path + "/*.src.rpm")
        file_list.sort()

    if not file_list:
        print 'No files found to import in directory: %s' % path
        sys.exit(1)

    tag_id = rtag.add_record(tag, path)
    if tag_id == 0:
        logging.critical('Unable to add tag "%s" to the database!' % tag)
        sys.exit(1)

    for file in file_list:
        if not os.path.isfile(file):
            print 'File %s not found!\n' % file
            next

        if type == 'binary':
            if not re_brpm.search(file) or re_srpm.search(file):
                print 'File %s is not a binary rpm!\n' % file
                next

        if type == 'source':
            if not re_srpm.search(file):
                print 'File %s is not a source rpm!\n' % file
                next

        record_add(tag_id, file, type)


def add_file_records(tag_id, record, file_list):
    """
    Function to add file records
    """
    logging.debug('in add_file_records(%s, %s, %s)' % (tag_id, record, file_list))

    for x in file_list.keys():
        rcommon.show_progress()
        if options.verbose:
            print 'File: %s' % file_list[x]['file']
        query  = "INSERT INTO files (t_record, p_record, files, f_user, f_group, f_is_suid, f_is_sgid, f_perms) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d, %s)" % (
            tag_id,
            record,
            db.sanitize_string(file_list[x]['file'].strip()),
            db.sanitize_string(file_list[x]['user']),
            db.sanitize_string(file_list[x]['group']),
            file_list[x]['is_suid'],
            file_list[x]['is_sgid'],
            file_list[x]['perms'])
        result = db.do_query(query)


def package_add_record(tag_id, file, type):
    """
    Function to add a package record
    """
    logging.debug('in package_add_record(%s, %s)' % (tag_id, file))

    path    = os.path.basename(file)
    if type == 'binary':
        rpmtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}|%{ARCH}' " + file.replace(' ', '\ '))
    else:
        rpmtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}' " + file.replace(' ', '\ '))
    tlist   = rpmtags.split('|')
    logging.debug("tlist is %s " % tlist)
    package = tlist[0].strip()
    version = tlist[1].strip()
    release = tlist[2].strip()
    pdate   = tlist[3].strip()
    if type == 'binary':
        arch    = tlist[4].strip()

    query = "SELECT tag FROM tags WHERE t_record = '%s' LIMIT 1" % tag_id
    tag   = db.fetch_one(query)

    if type == 'binary':
        query = "SELECT t_record, p_package, p_version, p_release, p_arch FROM packages WHERE t_record = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s' AND p_arch = '%s'" % (
            tag_id,
            db.sanitize_string(package),
            db.sanitize_string(version),
            db.sanitize_string(release),
            db.sanitize_string(arch))
    else:
        query = "SELECT t_record, p_package, p_version, p_release FROM packages WHERE t_record = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (
            tag_id,
            db.sanitize_string(package),
            db.sanitize_string(version),
            db.sanitize_string(release))
    result = db.fetch_all(query)
    if result:
        if type == 'binary':
            print 'File %s-%s-%s.%s is already in the database under tag %s' % (package, version, release, arch, tag)
        else:
            print 'File %s-%s-%s is already in the database under tag %s' % (package, version, release, tag)
        return(0)

    ## TODO: we shouldn't have to have p_tag here as t_record has the same info, but it
    ## sure makes it easier to sort alphabetically and I'm too lazy for the JOINs right now

    if type == 'binary':
        query  = "INSERT INTO packages (t_record, p_tag, p_package, p_version, p_release, p_date, p_arch) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s')" % (
            tag_id,
            db.sanitize_string(tag),
            db.sanitize_string(package),
            db.sanitize_string(version),
            db.sanitize_string(release),
            db.sanitize_string(pdate),
            db.sanitize_string(arch))
    else:
        query  = "INSERT INTO packages (t_record, p_tag, p_package, p_version, p_release, p_date) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')" % (
            tag_id,
            db.sanitize_string(tag),
            db.sanitize_string(package),
            db.sanitize_string(version),
            db.sanitize_string(release),
            db.sanitize_string(pdate))
    result = db.do_query(query)
    rcommon.show_progress(path)

    query    = "SELECT p_record FROM packages WHERE t_record = '%s' AND p_package = '%s' ORDER BY p_record DESC" % (tag_id, db.sanitize_string(package))
    p_record = db.fetch_one(query)
    if p_record:
            return(p_record)
    else:
        print 'Adding file %s failed!\n' % file
        return(0)


def run_binary_query(qstring, type):
    """
    Function to run the query for binary RPMs
    """
    logging.debug('in run_binary_query(%s, %s)' % (qstring, type))

    tag_id = rtag.lookup(options.tag)
    if options.tag and not tag_id:
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)
    elif options.tag and tag_id:
        tag_id =  tag_id['id']

    if not options.quiet:
        print 'Searching database records for substring match for %s (%s)' % (type, qstring)

    if options.ignorecase:
        ignorecase = ''
    else:
        ignorecase = 'BINARY'

    if type == 'files':
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s, f_user, f_group, f_is_suid, f_is_sgid, f_perms FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s %s " % (
            type, type, type, ignorecase, type)
    else:
        # query on type: provides, requires, symbols
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s %s " % (
            type, type, type, ignorecase, type)

    query = query + "LIKE '%" + db.sanitize_string(qstring) + "%'"

    if options.tag:
        query = "%s AND %s.t_record = '%d'"  % (query, type, tag_id)

    query  = query + " ORDER BY p_tag, p_package, " + type
    result = db.fetch_all(query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring (%s)' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring (%s)' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag  = row['p_tag']
            fromdb_rpm  = row['p_package']
            fromdb_ver  = row['p_version']
            fromdb_rel  = row['p_release']
            fromdb_date = row['p_date']
            fromdb_file = row[type]

            if type == 'files':
                fromdb_user    = row['f_user']
                fromdb_group   = row['f_group']
                fromdb_is_suid = row['f_is_suid']
                fromdb_is_sgid = row['f_is_sgid']
                fromdb_perms   = row['f_perms']

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s\n' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                rpm = fromdb_rpm

                if not rpm == lsrc:
                    if type == 'files' and options.ownership:
                        is_suid = ''
                        is_sgid = ''
                        if fromdb_is_suid == 1:
                            is_suid = '*'
                        if fromdb_is_sgid == 1:
                            is_sgid = '*'
                        print '%s: %s (%04d,%s%s,%s%s)' % (rpm, fromdb_file, int(fromdb_perms), is_suid, fromdb_user, is_sgid, fromdb_group)
                    else:
                        print '%s: %s' % (rpm, fromdb_file)

                if options.quiet:
                    lsrc = rpm
                else:
                    if options.extrainfo:
                        rpm_date = datetime.datetime.fromtimestamp(float(fromdb_date))
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", rpm_date.strftime('%a %b %d %H:%M:%S %Y'))
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring (%s)' % (options.tag, qstring)
        else:
            print 'No matches in database for substring (%s)' % qstring



if __name__ == '__main__':
    """
    The main program
    """
    global options, config

    rq_version = '0.3'
    if os.path.basename(sys.argv[0]) == 'rqs':
        rq_prog    = 'rqs'
        rq_type    = 'source'
    else:
        rq_prog    = 'rqp'
        rq_type    = 'binary'

    sys.stdout.write("%s %s ($Id$)\n\n" % (rq_prog, rq_version))
    # XXX: TODO add options to search files by ownership and sgid/suid status

    p = optparse.OptionParser(description="RPM package query tool",
                              prog=rq_prog,
                              version="%prog " + rq_version,
                              usage="%prog [-h] [-v] [-c <directory>] [-[q|r|p|z] <substring>] [-t <tag>]")
    p.add_option('-n', '--config', dest="conffile", help="Optional configuration file", metavar="FILE")
    p.add_option('-C', '--count', dest="count", default=False, action="store_true", help="Only output the count of query matches")
    p.add_option('-d', '--debug', dest="debug", default=False, action="store_true", help="Enable debugging output")
    p.add_option('-e', '--extrainfo', dest="extrainfo", default=False, action="store_true", help="Show extra info (version, release, date)")
    p.add_option('-i', '--ignorecase', dest="ignorecase", default=False, action="store_true", help="Case insensitive search")
    p.add_option('-l', '--list', dest="list", default=False, action="store_true", help="List database tags")
    if rq_type == 'binary':
        p.add_option('-o', '--ownership', dest="ownership", default=False, action="store_true", help="Display ownership information on files")
    if rq_type == 'source':
        p.add_option('-p', '--patch', dest="patch", default=False, action="store_true", help="List patched files when examining a src.rpm")
    p.add_option('-P', '--progress', dest="progress", default=False, action="store_true", help="Show processing progress")
    p.add_option('-Q', '--quiet', dest="quiet", default=False, action="store_true", help="Quiet query - show tag and package name only (or numeric count only)")
    if rq_type == 'source':
        p.add_option('-s', '--skip-tar', dest="skiptar", default=False, action="store_true", help="Skip tarfile extract when examining a src.rpm")
        p.add_option('-S', '--source-only', dest="sourceonly", default=False, action="store_true", help="Limit query to source files (no patches)")
    p.add_option('-T', '--suppresstag', dest="suppresstag", default=False, action="store_true", help="Suppress Tag and Path label output for queries") # was only in rqs -- why?
    p.add_option('-x', '--statistics', dest="stats", default=False, action="store_true", help="Show database statistics")
    p.add_option('-v', '--verbose', dest="verbose", default=False, action="store_true", help="Verbose output")
    dbgroup = optparse.OptionGroup(p, "Database Options")
    dbgroup.add_option('-a', '--add', dest="addfile", help="Add a " + rq_type + " rpm entry with TAG to the database", metavar="FILE")
    dbgroup.add_option('-c', '--createpath', dest="createpath", help="Create database entries with TAG from a " + rq_type + " rpm DIR", metavar="DIR")
    dbgroup.add_option('-D', '--delete', dest="tagdelete", help="Delete all TAG entries", metavar="TAG")
    if rq_type == 'source':
        dbgroup.add_option('-f', '--file', dest="src_examine", help="Examine a src.rpm FILE and output to stdout", metavar="FILE")
    dbgroup.add_option('-t', '--tag', dest="tag", help="TAG for created database entries or database queries", metavar="TAG")
    dbgroup.add_option('-u', '--update', dest="tagupdate", help="Update TAG entries (new/removed files in directory)", metavar="TAG")
    p.add_option_group(dbgroup)
    group = optparse.OptionGroup(p, "Query Options")
    if rq_type == 'binary':
        group.add_option('-p', '--provides', dest="provides", help="Query database for substring match on provides", metavar="STRING")
    group.add_option('-q', '--query', dest="query", help="Query database for substring match on files", metavar="STRING")
    if rq_type == 'binary':
        group.add_option('-r', '--requires', dest="requires", help="Query database for substring match on requires", metavar="STRING")
        group.add_option('-z', '--symbols', dest="symbols", help="Query database for substring match on symbols in binary files", metavar="STRING")
    if rq_type == 'source':
        group.add_option('-b', '--buildreqs', dest="buildreqs", help="Query database for substring match on BuildRequires", metavar="STRING")
        group.add_option('-o', '--info', dest="showinfo", help="Show all info on specified srpm", metavar="STRING")
        group.add_option('-z', '--ctags', dest="ctags", help="Query database for substring match on ctags data (functions, etc.)", metavar="STRING")
    p.add_option_group(group)
    (options, arguments) = p.parse_args()       # 'arguments' is a tuple of non-optioned things

    if len(sys.argv) == 1:      # no arguments passed
        p.print_help()
        sys.exit(0)

    # setup the options
    if rq_type == 'binary':
        if options.provides and options.query:
            p.error("--provides and --query are mutually exclusive")
        if options.provides and options.requires:
            p.error("--provides and --requires are mutually exclusive")
        if options.query and options.requires:
            p.error("--query and --provides are mutually exclusive")
        if options.provides and options.query and options.requires:
            p.error("--query, --provides, and --requires are mutually exclusive")

    if options.verbose and options.quiet:
        p.error("--quiet and --verbose are mutually exclusive")
    if options.tag and options.tagdelete:
        p.error("--tag and --delete are mutually exclusive; you do not need to use --tag")

    # setup logging facilities
    LOG_FILENAME = '%s/%s.log' % (os.getcwd(), rq_prog)
    LEVELS = {'debug'  : logging.DEBUG,
              'info'   : logging.INFO,
              'warning': logging.WARNING}

    if options.debug:
        filelevel = LEVELS.get('debug', logging.NOTSET)
        conslevel = LEVELS.get('debug', logging.NOTSET)
        filefmt   = '%(asctime)s %(filename)s(%(funcName)s[%(lineno)d]): %(levelname)s: %(message)s'

    if options.verbose:
        filelevel = LEVELS.get('info', logging.NOTSET)
        conslevel = LEVELS.get('info', logging.NOTSET)
        filefmt   = '%(asctime)s %(message)s'

    if not options.verbose and not options.debug:
        filelevel = LEVELS.get('info', logging.NOTSET)
        conslevel = LEVELS.get('warning', logging.NOTSET)
        filefmt   = '%(asctime)s %(message)s'

    logging.basicConfig(level=filelevel,
                        format=filefmt,
                        datefmt='%b %d %H:%M:%S',
                        filename=LOG_FILENAME,
                        filemode='a')
    console = logging.StreamHandler()
    console.setLevel(conslevel)
    consfmt = logging.Formatter('%(message)s')
    console.setFormatter(consfmt)
    logging.getLogger('').addHandler(console)

    logging.debug("%s starting, debug mode enabled; type => %s" % (rq_prog, rq_type))

    config = rq.basics.Config(options.conffile)
    db     = rq.db.DB(rq_type, config)

    # get the name of the database we want to talk to
    config['database'] = db.get_dbname()

    rtag = rq.tag.Tag(db, rq_type, config)

    rcommon = rq.basics.Common(options)

    if rq_type == 'source':
        import rq.source
        rqs = rq.source.Source(db, config, options, rtag, rcommon)

    # start doing useful things
    if options.list:
        rtag.list()

    if options.stats:
        if options.tag:
            rtag.showdbstats(options.tag)
        else:
            rtag.showdbstats()

    if options.tag:
        logging.debug('Tag:\t%s\n' % options.tag)

    if options.tagdelete:
        rtag.delete_entries(options.tagdelete)
        sys.exit(0)

    if options.tagupdate:
        rtag.update_entries(options.tagupdate)
        sys.exit(0)

    if options.query:
        if rq_type == 'binary':
            run_binary_query(options.query, 'files')
        elif rq_type == 'source':
            rqs.query('files')
        sys.exit(0)

    if rq_type == 'binary':
        if options.provides:
            run_binary_query(options.provides, 'provides')
            sys.exit(0)

        if options.requires:
            run_binary_query(options.requires, 'requires')
            sys.exit(0)

        if options.symbols:
            run_binary_query(options.symbols, 'symbols')

    if rq_type == 'source':
        if options.ctags:
            rqs.query('ctags')
            sys.exit(0)

        if options.buildreqs:
            rqs.query('buildreqs')
            sys.exit(0)

        if options.showinfo:
            rqs.showinfo()
            sys.exit(0)

        if options.src_examine:
            rqs.examine()
            sys.exit(0)

    # this option is strange... it must be for adding a file, but should a single file
    # have a new tag?  or can we add it (despite the path) to an existing tag?
    # XXX: it also needs to be able to support numerous files at once
    # XXX: TODO
    if options.addfile:
        if not options.tag:
            logging.critical('The --add option requires a tag entry!')
            sys.exit(1)

        # are we passed a file, or directory?
        if os.path.isfile(options.addfile):
            # passed a file, we want the path
            path = os.path.abspath(os.path.dirname(options.addfile))
        else:
            # passed a directory
            path = os.path.abspath(options.addfile)

        havetag = rtag.lookup(options.tag)

        if not havetag:
            logging.critical('The --add option requires a tag that already exists!')
            sys.exit(1)

        if path != havetag['path']:
            logging.critical('Tag (%s) is already in the database with path: %s' % (options.tag, havetag['path']))
            logging.critical('Cannot add to an existing tag from a different path!  Unwilling to use %s to add a new file!' % path)
            sys.exit(1)

        # the rest of this just makes no sense as-is so bail
        print 'The --add option is non-functional.  Sorry.'
        sys.exit(1)

        addfiles = []
        addfiles.append(path)

        if len(arguments) > 0:
            addfiles.extend(arguments)

        for afile in addfiles:
            print afile
            #record_add(options.tag, afile, rq_type)

        sys.exit(0)

    if options.createpath:
        createpath = os.path.abspath(options.createpath)
        logging.debug('Dir:\t%s' % createpath)
        if not options.tag:
            sys.stdout.write('The --create option requires a tag entry!\n')
            sys.exit(1)

        sys.stdout.write('Searching for rpms to import...\n\n')
        rpm_add_directory(options.tag, createpath, rq_type)
        sys.exit(0)

    # if we get here, we have completely invalid arguments
    p.print_help()
    sys.exit(0)
