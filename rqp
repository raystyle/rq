#!/usr/bin/env python
"""
This program extracts data from RPM and SRPM packages and stores it in
a database for later querying.

based on the srpm script of similar function copyright (c) 2005 Stew Benedict <sbenedict@mandriva.com>
copyright (c) 2007-2009 Vincent Danen <vdanen@linsec.ca>

$Id$
"""

import optparse, os, sys, re, datetime, commands, shutil, tempfile
import MySQLdb, MySQLdb.cursors
from glob import glob
#import MySQLdb.connect

re_srpm    = re.compile(r'\.src\.rpm$')
re_brpm    = re.compile(r'\.rpm$')
re_patch   = re.compile(r'\.(diff|dif|patch)(\.bz2|\.gz)?$')
re_tar     = re.compile(r'\.(tar)(\.bz2|\.gz)?$')
re_targz   = re.compile(r'\.tar\.gz$')
re_tarbz   = re.compile(r'\.tar\.bz2$')
re_patchgz = re.compile(r'\.(patch|diff|dif)(\.gz)$')
re_patchbz = re.compile(r'\.(patch|diff|dif)(\.bz2)$')


def db_connect(type, config):
    """
    function db_connect(type, config)

    Function to connect to the database.  It requires two arguments: type is
    'source' or 'binary' to know which database we are working with and config
    is the database configuration information.  It returns two objects: the db
    object for connecting to the database and a modified config list that has
    the appropriate database name (for whether it is called with type 'source'
    or type 'binary').
    """

    if config['hostspec'] == '':
        sys.stderr.write('Missing hostspec in the configuration!\n')
        sys.exit(1)
    if config['username'] == '':
        sys.stderr.write('Missing username in the configuration!\n')
        sys.exit(1)
    if config['password'] == '':
        sys.stderr.write('Missing password in the configuration!\n')
        sys.exit(1)

    if type == 'binary':
        if (config['rpm_database'] == ''):
            sys.stderr.write('Missing rpm_database in the configuration!\n')
            sys.exit(1)
        else:
            config['database'] = config['rpm_database']

    if type == 'source':
        if (config['srpm_database'] == ''):
            sys.stderr.write('Missing srpm_database in the configuration!\n')
            sys.exit(1)
        else:
            config['database'] = config['srpm_database']

    print_debug('Using host=>%s, user=>%s, db=>%s' % (config['hostspec'], config['username'], config['database']))

    try:
        db = MySQLdb.connect(host=config['hostspec'],
                             user=config['username'],
                             passwd=config['password'],
                             db=config['database'],
                             cursorclass=MySQLdb.cursors.DictCursor)
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        sys.exit(1)

    return (db, config)


def db_close():
    """
    function db_close()

    Function to close connections to the database
    """
    db.commit()
    db.close()


def db_fetchall(query):
    """
    function db_fetchall(query)

    Function to perform database queries.  It takes one argument, the query to
    execute (a SELECT statement), and returns the results of the query if the
    query was successful, returns False if not.  This function is meant to be
    used with multi-result queries.
    """
    print_debug('  in db_fetchall()')
    print_debug('  => query is: %s' % query)

    try:
        cursor = db.cursor()
        cursor.execute("set autocommit=0")
        cursor.execute(query)
        results = cursor.fetchall()
        cursor.close()

        if results:
            return results
        else:
            return False
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        sys.exit(1)


def db_fetchone(query):
    """
    function db_fetchone(query)

    Function to perform database queries.  It takes one argument, the query to
    execute (a SELECT statement), and returns the results of the query if the
    query was successful, returns False if not.  This function is meant to be
    used with single-result queries.
    """
    print_debug('  in db_fetchone()')
    print_debug('  => query is: %s' % query)

    try:
        cursor = db.cursor()
        cursor.execute(query)
        results = cursor.fetchone()
        cursor.close()
        if results:
            key = results.keys()
            return(results[key[0]])
        else:
            return False
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        sys.exit(1)


def db_doquery(query):
    """
    Function to perform an actual update (UPDATE/INSERT) query (non-SELECT) from the database
    """
    print_debug('  in db_doquery()')
    print_debug('  => query is: %s' % query)

    try:
        cursor = db.cursor()
        cursor.execute(query)
        cursor.close()
    except MySQLdb.Error, e:
        sys.stderr.write('MySQL error %d: %s\n' % (e.args[0], e.args[1]))
        sys.exit(1)


def sanitize_string(string):
    """
    String to cleanup a string to remove characters that will cause problems
    with the database
    """
    #print_debug('  in sanitize_string(%s)' % string)
    if string:
        # escape single and double quotes
        new_string = re.sub('''(['";])''', r'\\\1', string)
    else:
        new_string = None
    return(new_string)


def print_debug(string):
    """
    Function to print debug strings
    """
    if options.debug:
        sys.stderr.write("=> DEBUG: %s\n" % string)


def print_verbose(string):
    """
    Function to print verbose strings
    """
    if options.verbose:
        sys.stdout.write("%s\n" % string)


def read_config(config_file):
    """
    Function to read the configuration file
    """
    print_debug("in read_config(%s)" % config_file)

    config = {}
    for line in open(config_file):
        line = line.rstrip()
        if not line:                                        # ignore empties
            continue
        if line.startswith("#") or line.startswith(";"):    # and ignore comments
            continue

        # Split on the first "=", this allows for values to have a "=" in them
        (config_name, config_value) = line.split("=", 1)
        config_name         = config_name.strip()
        config[config_name] = config_value

    return config


def tag_list():
    """
    Function to show database tags
    """
    print_debug("in tag_list()")

    query = 'SELECT tag, path, tdate FROM tags ORDER BY tag'
    results = db_fetchall(query)
    if results:
        for row in results:
            print 'Tag: %-22sDate Added: %-18s\n  Path: %s\n' % (row['tag'], row['tdate'], row['path'])
    else:
        print 'No tags exist in the database!\n'

    db_close()
    sys.exit(0)


def tag_delete_entries(tag, type='binary'):
    """
    Function to delete database tags and associated entries
    """
    print_debug('in tag_delete_entries(%s)' % tag)

    to_remove = []

    query  = "SELECT tag FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    result = db_fetchone(query)

    if not result:
        print 'No matching tag found for entry %s!\n' % tag
        sys.exit(1)
    else:
        print 'Removing tag (%s) from Tags...\n' % tag
        query = "DELETE FROM tags WHERE tag = '%s'" % sanitize_string(tag)
        db_doquery(query)

        query  = "SELECT DISTINCT p_record FROM packages WHERE p_tag = '%s'" % sanitize_string(tag)
        result = db_fetchall(query)
        if result:
            for row in result:
                to_remove.append(row['p_record'])

        nrecs = len(to_remove)
        if nrecs > 0:
            if nrecs == 1:
                word_package = 'Package'
                word_entry   = 'entry'
            else:
                word_package = 'Packages'
                word_entry   = 'entries'

            sys.stdout.write('Removing %d tagged %s %s for %s... ' % (nrecs, word_package, word_entry, tag))

            for rnum in to_remove:
                if type == 'binary':
                    tables = ('packages', 'requires', 'provides', 'files')
                if type == 'source':
                    tables = ('packages', 'sources', 'files')
                for table in tables:
                    query = "DELETE FROM %s WHERE p_record = '%d'" % (table, rnum)
                    res   = db_doquery(query)

            sys.stdout.write(' done\n')
        else:
            sys.stdout.write('No matching package tags to remove.\n')


def tag_update_entries(tag, type='binary'):
    """
    function to update entries for a given tag
    """
    print_debug('in tag_update_entries(%s)' % tag)
    #
    # this function is designed for src.rpm handling, but we can update it for binary rpm handling too
    # XXX: TODO
    #

    to_remove = []
    to_add    = []

    query = "SELECT DISTINCT path FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    path  = db_fetchone(query)
    if path:
        print_verbose('Update tag (%s) entries from %s...' % (tag, path))
        # get the existing entries
        query  = "SELECT DISTINCT p_record, p_tag, p_package, p_version, p_release FROM packages WHERE p_tag = '%s'" % sanitize_string(tag)
        result = db_fetchall(query)
        for row in result:
            pname = '%s-%s-%s.src.rpm' % (row['p_package'], row['p_version'], row['p_release'])
            print_verbose('Checking for %s in %s...' % (pname, path))
            if os.path.isfile(pname):
                print_verbose('OK')
            else:
                print_verbose('Missing')
                to_remove.append(result['p_record'])
        src_list = glob(path + "/*.rpm")
        src_list.sort()
        for src_rpm in src_list:
            print_verbose('Checking for %s in database...' % src_rpm)
            rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}' " + src_rpm)
            tlist   = rtags.split('|')
            package = tlist[0].strip()
            version = tlist[1].strip()
            release = tlist[2].strip()

            query   = "SELECT p_package FROM packages WHERE p_tag = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (sanitize_string(tag), sanitize_string(package), sanitize_string(version), sanitize_string(release))
            package = db_fetchone(query)
            if package:
                print_verbose('OK')
            else:
                print_verbose('Adding')
                to_add.append(src_rpm)
    else:
        sys.stdout.write('No Tag entry found for tag: %s\n' % tag)

    if to_remove:
        print_verbose('Removing tagged entries for tag: %s...' % tag)
        if type == 'binary':
            tables = ('packages', 'requires', 'provides', 'files')
        if type == 'source':
            tables = ('packages', 'sources')
        for rnum in to_remove:
            for table in tables:
                query  = "DELETE FROM %s WHERE p_record = %d" % (table, rnum)
                result = db_doquery(query)

    if to_add:
        print_verbose('Adding tagged entries for tag: %s...' % tag)
        for rpm in to_add:
            record_add(tag, rpm, type)


def showdbstats(type):
    """
    Function to show database info
    """
    print_debug("in showdbstats(%s)" % type)

    query   = "SELECT count(*) FROM tags"
    c_tags  = db_fetchone(query)
    query   = "SELECT count(*) FROM packages"
    c_pkgs  = db_fetchone(query)
    if type == 'binary':
        query   = "SELECT count(*) FROM requires"
        c_reqs  = db_fetchone(query)
        query   = "SELECT count(*) FROM provides"
        c_provs = db_fetchone(query)
    else:
        query = "SELECT count(*) FROM sources"
        c_src = db_fetchone(query)
    query   = "SELECT count(*) FROM files"
    c_files = db_fetchone(query)

    # get the size of the database as well
    size   = 0.00
    bytes  = ''
    query  = "SHOW TABLE STATUS"
    tbsize = db_fetchall(query)

    for x in tbsize:
        size += x['Data_length']    #['Data_length']
    count = 0

    while size > 1024:
        size = size / 1024
        count += 1
        if count == 1:
            bytes = 'KB'
        if count == 2:
            bytes = 'MB'
        if count == 3:
            bytes = 'GB'
            break

    print 'Database statistics:\n'
    print '   Database  => User: %s, Host: %s, Database: %s' % (config['username'], config['hostspec'], config['database'])
    print '   Data size => %2.2f %s\n' % (size, bytes)
    print '   Tag records : %-15d Package records : %-15d' % (c_tags, c_pkgs)
    if type == 'binary':
        print '   File records: %-15d Requires records: %-15d' % (c_files, c_reqs)
        print '                                 Provides records: %-15d\n' % c_provs
    else:
        print '   File records: %-15d Source records  : %-15d' % (c_files, c_src)
    sys.exit(0)


def show_progress(prefix=False):
    """
    Function to show progress
    """
    global pstate

    if not options.verbose and not options.debug and options.progress:
        if not prefix:
            if pstate == 1:
                sys.stdout.write('.')
            pstate = pstate + 1
            if pstate > 20:
                pstate = 1
            return

        if prefix != 'files' and prefix != 'sources' and prefix != '':
            sys.stdout.write("%s: " % prefix.strip())
            pstate = 1
            return
        elif prefix != lprefix:
            sys.stdout.write('\t%s: ' %prefix)
            lprefix = prefix
            return


def tag_lookup(tag):
    """
    Function to see if a tag exists
    """
    print_debug('in tag_lookup(%s)' % tag)

    query = "SELECT path FROM tags WHERE tag = '%s' LIMIT 1" % sanitize_string(tag)
    path  = db_fetchone(query)
    if path:
        return(path)
    else:
        return False


def tag_check(tag, file):
    """
    Function to check for the existence of tags
    """
    print_debug('in tag_check(%s, %s)' % (tag, file))

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)

    tpath = tag_lookup(tag)

    if tpath:
        print_debug('Tag (%s) already exists in the database with path: %s' % (tag, tpath))
        return True
    else:
        print_debug('Tag or path does NOT exist in the database')
        return False

#        if len(result) > 0:
#            if result[1] != path:
#                #print 'Tag (%s) is already in the database with path: %s\n' % (tag, result[1])
#                #sys.exit(1)
#                return(True)
#            else:
#                return(False)
#    except:
#        return(False)


def tag_add_record(tag, file):
    """
    Function to add a tag record
    """
    print_debug('in tag_add_record(%s, %s)' % (tag, file))

    cur_date = datetime.datetime.now()
    cur_date = cur_date.strftime('%a %b %d %H:%M:%S %Y')

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    # we can have multiple similar paths, but not multiple similar tags
    query = "SELECT tag FROM tags WHERE tag = '%s'" % sanitize_string(tag)
    dbtag = db_fetchone(query)
    if dbtag:
        print 'Tag (%s) already exists in the database!\n' % tag
        db_close()
        sys.exit(1)

    query = "INSERT INTO tags (tag, path, tdate) VALUES ('%s', '%s', '%s')" % (sanitize_string(tag.strip()), sanitize_string(path.strip()), cur_date)
    db_doquery(query)
    return(0)


def record_add(tag, file, type):
    """
    Function to add a record to the database
    """
    print_debug('in record_add(%s, %s, %s)' % (tag, file, type))

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    print_debug('Path:\t%s' % path)

    file_rpm_check(file, type)

    record = package_add_record(tag, file, type)
    if not record:
        return

    file_list = rpm_list(file)
    if not file_list:
        return

    if type == 'binary':
        print_debug('Add file records for package record: %s' % record)
        add_file_records(record, file_list)
        add_file_requires(record, file)
        add_file_provides(record, file)

    if type == 'source':
        print_debug('Add source records for package record: %s' % record)
        add_source_records(record, file_list)
        cpio_dir = tempfile.mkdtemp()
        try:
            current_dir = os.getcwd()
            os.chdir(cpio_dir)
            source_get_all_files(file)
            add_source_file_records(record, file_list)
            os.chdir(current_dir)
        finally:
            print_debug('Removing temporary directory: %s...' % cpio_dir)
            shutil.rmtree(cpio_dir)

    if options.progress:
        sys.stdout.write('\n')


def source_get_all_files(file):
    """
    Function to get the source and patch files from a SRPM
    """
    print_debug('in source_get_all_files(%s)' % file)
    source_get_tar_files(file)
    source_get_patch_files(file)


def source_get_tar_files(file):
    """
    Function to get the tar files from a SRPM
    """
    print_debug('in source_get_tar_files(%s)' % file)

    command = 'rpm2cpio "%s" | cpio -i --quiet "*.tar.?z*" 2>/dev/null' % file
    (rc, output) = commands.getstatusoutput(command)
    print_debug('called cpio (rc=%s): %s' % (rc, command))

    if not rc == 0:
        sys.stderr.write('Failed to execute rpm2cpio!  Command was: %s\nOutput was:\n(rc: %s) %s\n' % (command, rc, output))
        sys.exit(1)


def source_get_patch_files(file):
    """
    Function to get the patch files from a SRPM
    """
    print_debug('in source_get_patch_files(%s)' % file)

    command = 'rpm2cpio %s | cpio -i --quiet "*patch*" 2>/dev/null' % file
    (rc, output) = commands.getstatusoutput(command)
    print_debug('called cpio (rc=%s): %s' % (rc, output))

    if not rc == 0:
        sys.stderr.write('Failed to execute rpm2cpio!  Command was: %s\nOutput was:\n(rc: %s) %s\n' % (command, rc, output))
        sys.exit(1)


def add_file_requires(record, file):
    """
    Function to add requires to the database
    """
    print_debug('in add_file_requires(%s, %s)' % (record, file))

    list = commands.getoutput("rpm -qp --nosignature --requires " + file + " | egrep -v '(rpmlib|GLIBC|GCC|rtld)' | uniq")
    list = list.splitlines()
    for dep in list:
        if dep:
            show_progress()
            if options.verbose:
                print 'Dependency: %s' % dep
            query  = "INSERT INTO requires (p_record, requires) VALUES ('%s', '%s')" % (record, sanitize_string(dep.strip()))
            result = db_doquery(query)


def add_file_provides(record, file):
    """
    Function to add provides to the database
    """
    print_debug('in add_file_provides(%s, %s)' % (record, file))

    list = commands.getoutput("rpm -qp --nosignature --provides " + file)
    list = list.splitlines()
    for prov in list:
        if prov:
            show_progress()
            if options.verbose:
                print 'Provides: %s' % prov
            query  = "INSERT INTO provides (p_record, provides) VALUES ('%s', '%s')" % (record, sanitize_string(prov.strip()))
            result = db_doquery(query)


def rpm_list(file, raw=False):
    """
    Function to get the list of files in an RPM
    """
    print_debug('in rpm_list(%s)' % file)

    list  = commands.getoutput("rpm -qlvp --nosignature " + file)

    if list == '(contains no files)' or list == '':
        return False

    if raw:
        return(list)

    list  = list.splitlines()
    rlist = {}
    count = 0
    for entry in list:
        print_debug('processing: ' + entry) ### DEBUG
        is_suid = 0
        is_sgid = 0
        foo = entry.split()

        # this actually really stinks because we are allowed usernames longer
        # than 8 characters, but rpm -qlv will only display the first 8 characters
        # of the owner/group name -- not cool at all
        if len(foo[2]) > 8:
            user  = foo[2][:8]
            group = foo[2][8:]
            fname = foo[7]
        else:
            user  = foo[2]
            group = foo[3]
            fname = foo[8]
        if foo[0][3] == 's':
            is_suid = 1
        if foo[0][6] == 's':
            is_sgid = 1
        rlist[count] = {'file': fname, 'user': user, 'group': group, 'is_suid': is_suid, 'is_sgid': is_sgid}
        count += 1

    return(rlist)


def rpm_add_directory(tag, path, type='binary'):
    """
    Function to import a directory full of RPMs
    """
    print_debug('in rpm_add_directory(%s, %s, %s)' % (tag, path, type))

    if not os.path.isdir(path):
        print 'Path (%s) is not a valid directory!' % path
        sys.exit(1)

    if type == 'binary':
        file_list = glob(path + "/*.rpm")
        file_list.sort()

    if type == 'source':
        file_list = glob(path + "/*.src.rpm")
        file_list.sort()

    if not file_list:
        print 'No files found to import in directory: %s' % path
        sys.exit(1)

    new_tag = tag_add_record(tag, path)
    if new_tag:
        sys.exit(1)

    for file in file_list:
        if not os.path.isfile(file):
            print 'File %s not found!\n' % file
            next

        if type == 'binary':
            if not re_brpm.search(file) or re_srpm.search(file):
                print 'File %s is not a binary rpm!\n' % file
                next

        if type == 'source':
            if not re_srpm.search(file):
                print 'File %s is not a source rpm!\n' % file
                next

        record_add(tag, file, type)


def add_file_records(record, file_list):
    """
    Function to add file records
    """
    print_debug('in add_file_records(%s, %s)' % (record, file_list))

    for x in file_list.keys():
        show_progress()
        if options.verbose:
            print 'File: %s' % file_list[x]['file']
        query  = "INSERT INTO files (p_record, files, f_user, f_group, f_is_suid, f_is_sgid) VALUES ('%s', '%s', '%s', '%s', %d, %d)" % (
            record,
            sanitize_string(file_list[x]['file'].strip()),
            sanitize_string(file_list[x]['user']),
            sanitize_string(file_list[x]['group']),
            file_list[x]['is_suid'],
            file_list[x]['is_sgid'])
        result = db_doquery(query)


def add_source_records(record, file_list):
    """
    Function to add source records
    """
    print_debug('in add_source_records(%s, %s)' % (record, file_list))

    for x in file_list.keys():
        print_debug('processing source: ' + file_list[x]['file'])
        show_progress()
        stype = ''

        if re_patch.search(file_list[x]['file']):
            stype = 'P'
        if re_tar.search(file_list[x]['file']):
            stype = 'S'

        # we only care about source and patch files, nothing else
        if stype == '':
            continue

        if options.verbose:
            print 'Source: %s, Type: %s' % (file_list[x]['file'], stype)
        query  = "INSERT INTO sources (p_record, s_type, s_file) VALUES ('%s', '%s', '%s')" % (record, stype, sanitize_string(file_list[x]['file'].strip()))
        result = db_doquery(query)


def add_source_file_records(record, file_list):
    """
    Function to add all source file records
    """
    print_debug('in add_source_file_records(%s, %s)' % (record, file_list))

    for x in file_list.keys():
        good_src = False
        print_debug('processing file: ' + file_list[x]['file']) ### DEBUG

        if re_patch.search(file_list[x]['file']):
            flist = patch_list(file_list[x]['file'])
            good_src = True

        if re_tar.search(file_list[x]['file']):
            flist = tar_list(file_list[x]['file'])
            good_src = True

        # only proceed for tarballs and patches
        if good_src:
            files = flist.split()

            # get the s_record for this source from the db
            query   = "SELECT s_record FROM sources WHERE p_record = '%s' AND s_file = '%s'" % (record, sanitize_string(file_list[x]['file']))
            db_srec = db_fetchone(query)
            if not db_srec:
                sys.stderr.write('adding files from %s failed...' % file_list[x]['file'])
                sys.exit(1)

            for dfile in files:
                if dfile.endswith('/'):     # skip directories
                    pass
                else:
                    show_progress()
                    print_verbose('File: %s\n' % dfile)
                    query  = "INSERT INTO files (p_record, s_record, f_file) VALUES ('%s', '%s', '%s')" % (record, db_srec, sanitize_string(dfile))
                    result = db_doquery(query)


def patch_list(file):
    """
    Function to get a list of files that a patch touches
    """
    print_debug('in patch_list(%s)' % file)

    grep = 'grep'

    if re_patchgz.search(file):
        grep = 'zgrep'

    if re_patchbz.search(file):
        grep = 'bzgrep'

    list = commands.getoutput(grep + " '^+++' " + file + " 2>/dev/null | awk '{print $2}'")

    return(list)


def tar_list(file):
    """
    Function to get a list of files in a tarball
    """
    print_debug('in tar_list(%s)' % file)

    comp = 'tf'
    if re_targz.search(file):
        comp = 'tzf'
    if re_tarbz.search(file):
        comp = 'tjf'

    command = 'tar -%s "%s" --exclude=.svn --exclude=CVS --exclude=AUTHORS --exclude=Makefile --exclude=ChangeLog --exclude=COPYING --exclude=TODO 2>/dev/null' % (comp, file)

    (rc, list) = commands.getstatusoutput(command)
    print_debug('called tar (rc=%s): %s\n%s' % (rc, command, list))

    return(list)


def package_add_record(tag, file, type):
    """
    Function to add a package record
    """
    print_debug('in package_add_record(%s, %s)' % (tag, file))

    path    = os.path.basename(file)
    if type == 'binary':
        rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}|%{ARCH}' " + file)
    else:
        rtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}' " + file)
    tlist   = rtags.split('|')
    package = tlist[0].strip()
    version = tlist[1].strip()
    release = tlist[2].strip()
    pdate   = tlist[3].strip()
    if type == 'binary':
        arch    = tlist[4].strip()

    if type == 'binary':
        query = "SELECT p_tag, p_package, p_version, p_release, p_arch FROM packages WHERE p_tag = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s' AND p_arch = '%s'" % (
            sanitize_string(tag),
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release),
            sanitize_string(arch))
    else:
        query = "SELECT p_tag, p_package, p_version, p_release FROM packages WHERE p_tag = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (
            sanitize_string(tag),
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release))
    result = db_fetchall(query)
    if result:
        if type == 'binary':
            print 'File %s-%s-%s.%s is already in the database under tag %s' % (package, version, release, arch, tag)
        else:
            print 'File %s-%s-%s is already in the database under tag %s' % (package, version, release, tag)
        return(0)

    if type == 'binary':
        query  = "INSERT INTO packages (p_tag, p_package, p_version, p_release, p_date, p_arch) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')" % (
            sanitize_string(tag),
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release),
            sanitize_string(pdate),
            sanitize_string(arch))
    else:
        query  = "INSERT INTO packages (p_tag, p_package, p_version, p_release, p_date) VALUES ('%s', '%s', '%s', '%s', '%s')" % (
            sanitize_string(tag),
            sanitize_string(package),
            sanitize_string(version),
            sanitize_string(release),
            sanitize_string(pdate))
    result = db_doquery(query)
    show_progress(path)

    query    = "SELECT p_record FROM packages WHERE p_tag = '%s' AND p_package = '%s' ORDER BY p_record DESC" % (sanitize_string(tag), sanitize_string(package))
    p_record = db_fetchone(query)
    if p_record:
            return(p_record)
    else:
        print 'Adding file %s failed!\n' % file
        return(0)


def file_rpm_check(file, type='binary'):
    """
    Function to check whether the file is a source or binary RPM

    The default is binary
    """
    print_debug('in file_rpm_check(%s, %s)' % (file, type))

    if not os.path.isfile(file):
        print 'File %s not found!\n' % file
        sys.exit(1)

    if type == 'binary':
        if not re_brpm.search(file) or re_srpm.search(file):
            print 'File %s is not a binary rpm!\n' % file
            sys.exit(1)

    if type == 'source':
        if not re_srpm.search(file):
            print 'File %s is not a source rpm!\n' % file
            sys.exit(1)


def run_binary_query(qstring, type):
    """
    Function to run the query for binary RPMs
    """
    print_debug('in run_binary_query(%s, %s)' % (qstring, type))

    if options.tag and not tag_lookup(options.tag):
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)

    if not options.quiet:
        print 'Searching database records for substring match for %s (%s)' % (type, qstring)

    if type == 'files' and options.ownership:
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s, f_user, f_group, f_is_suid, f_is_sgid FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s " % (type, type, type, type)
    else:
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s " % (type, type, type, type)


    if options.ignorecase:
        query = query + "LIKE '%" + sanitize_string(qstring) + "%'"
    else:
        query = query + "LIKE '%" + sanitize_string(qstring) + "%'"

    if options.tag:
        query = query + " AND p_tag = '" + sanitize_string(options.tag) + "'"

    query  = query + " ORDER BY p_tag, p_package, " + type
    result = db_fetchall(query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring (%s)' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring (%s)' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag  = row['p_tag']
            fromdb_rpm  = row['p_package']
            fromdb_ver  = row['p_version']
            fromdb_rel  = row['p_release']
            fromdb_date = row['p_date']
            fromdb_file = row[type]
            if type == 'files' and options.ownership:
                fromdb_user = row['f_user']
                fromdb_group = row['f_group']
                fromdb_is_suid = row['f_is_suid']
                fromdb_is_sgid = row['f_is_sgid']

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s\n' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                rpm = fromdb_rpm

                if not rpm == lsrc:
                    if type == 'files' and options.ownership:
                        is_suid = ''
                        is_sgid = ''
                        if fromdb_is_suid == 1:
                            is_suid = '*'
                        if fromdb_is_sgid == 1:
                            is_sgid = '*'
                        print '%s: %s (%s%s, %s%s)' % (rpm, fromdb_file, is_suid, fromdb_user, is_sgid, fromdb_group)
                    else:
                        print '%s: %s' % (rpm, fromdb_file)

                if options.quiet:
                    lsrc = rpm
                else:
                    if options.extrainfo:
                        rpm_date = datetime.datetime.fromtimestamp(float(fromdb_date))
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", rpm_date.strftime('%a %b %d %H:%M:%S %Y'))
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring (%s)' % (options.tag, qstring)
        else:
            print 'No matches in database for substring (%s)' % qstring


def run_source_query(qstring):
    """
    Function to run the query for source RPMs
    """
    print_debug('in run_source_query(%s)' % qstring)

    if options.tag and not tag_lookup(options.tag):
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)

    if not options.quiet:
        print 'Searching database records for substring match (%s)' % qstring

    query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, s_type, s_file, f_file FROM files JOIN sources ON (sources.s_record = files.s_record) JOIN packages ON (packages.p_record = files.p_record) WHERE f_file "

    if options.ignorecase:
        query = query + "LIKE '%" + sanitize_string(qstring) + "%'"
    else:
        query = query + "LIKE '%" + sanitize_string(qstring) + "%'"

    if options.sourceonly:
        query = query + " AND s_type = 'S'"

    if options.tag:
        query = query + " AND p_tag = '" + sanitize_string(options.tag) + "'"

    query  = query + " ORDER BY p_tag, p_package, s_type, s_file, f_file"
    result = db_fetchall(query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring (%s)' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring (%s)' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag   = row['p_tag']
            fromdb_rpm   = row['p_package']
            fromdb_ver   = row['p_version']
            fromdb_rel   = row['p_release']
            fromdb_date  = row['p_date']
            fromdb_type  = row['s_type']
            fromdb_file  = row['s_file']
            fromdb_sfile = row['f_file']

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s\n' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                srpm  = '%s-%s-%s' % (fromdb_rpm, fromdb_ver, fromdb_rel)
                stype = 'source'

                if options.quiet:
                    lsrc = srpm
                    sys.stdout.write('%s\n' % srpm)
                else:
                    if fromdb_type == 'P':
                        stype = 'patch'
                    if options.extrainfo:
                        rpm_date = datetime.datetime.fromtimestamp(float(fromdb_date))
                        print '\n%-16s%-30s' % (stype.title() + " File:", fromdb_file)
                        print '%-16s%-30s' % ("Source Path:", fromdb_sfile)
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", rpm_date.strftime('%a %b %d %H:%M:%S %Y'))
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)
                    else:
                        sys.stdout.write('%s: (%s) %s: %s\n' % (srpm, stype, fromdb_file, fromdb_sfile))

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring (%s)' % (options.tag, qstring)
        else:
            print 'No matches in database for substring (%s)' % qstring


def run_source_examine(file):
    """
    Examine a src.rpm and output the details
    """
    print_debug('in run_source_examine(%s)' % file)

    file_rpm_check(file, 'source')

    file = path = os.path.abspath(file)

    print 'Examining %s...\n' % file

    # stage 1, list the rpm content
    src_list = rpm_list(file, raw=True)
    print 'SRPM Contents:\n%s\n' % src_list

    file_list = rpm_list(file)

    cpio_dir = tempfile.mkdtemp()
    try:
        current_dir = os.getcwd()
        os.chdir(cpio_dir)

        # stage 2, list patched files
        if options.patch:
            source_get_patch_files(file)
            for x in file_list.keys():
                if re_patch.search(file_list[x]['file']):
                    plist = patch_list(file_list[x]['file'])
                    print 'Patch file %s modifies:\n%s\n' % (file_list[x]['file'], plist)

        # stage 3, list the tarball contents
        if not options.skiptar:
            source_get_tar_files(file)
            for y in file_list.keys():
                if re_tar.search(file_list[y]['file']):
                    tlist = tar_list(file_list[y]['file'])
                    print 'Tarfile %s contents:\n%s\n' % (file_list[y]['file'], tlist)

        os.chdir(current_dir)
    finally:
        print_debug('Removing temporary directory: %s...' % cpio_dir)
        shutil.rmtree(cpio_dir)


if __name__ == '__main__':
    """
    The main program
    """
    global options, config

    rq_version = '0.2'
    if os.path.basename(sys.argv[0]) == 'rqs':
        rq_prog    = 'rqs'
        rq_type    = 'source'
    else:
        rq_prog    = 'rqp'
        rq_type    = 'binary'

    sys.stdout.write(rq_prog + " %s ($Id$)\n\n" % rq_version)

    # XXX: TODO add options to search files by ownership and sgid/suid status

    p = optparse.OptionParser(description="RPM package query tool",
                              prog=rq_prog,
                              version="%prog " + rq_version,
                              usage="%prog [-h] [-v] [-c <directory>] [-[q|r|p] <substring>] [-t <tag>]")
    p.add_option('-C', '--count', dest="count", default=False, action="store_true", help="Only output the count of query matches")
    p.add_option('-d', '--debug', dest="debug", default=False, action="store_true", help="Enable debugging output")
    p.add_option('-e', '--extrainfo', dest="extrainfo", default=False, action="store_true", help="Show extra info (version, release, date)")
    p.add_option('-i', '--ignorecase', dest="ignorecase", default=False, action="store_true", help="Case insensitive search")
    p.add_option('-l', '--list', dest="list", default=False, action="store_true", help="List database tags")
    if rq_type == 'binary':
        p.add_option('-o', '--ownership', dest="ownership", default=False, action="store_true", help="Display ownership information on files")
    if rq_type == 'source':
        p.add_option('-p', '--patch', dest="patch", default=False, action="store_true", help="List patched files when examining a src.rpm")
    p.add_option('-P', '--progress', dest="progress", default=False, action="store_true", help="Show processing progress")
    p.add_option('-Q', '--quiet', dest="quiet", default=False, action="store_true", help="Quiet query - show tag and package name only (or numeric count only)")
    if rq_type == 'source':
        p.add_option('-s', '--skip-tar', dest="skiptar", default=False, action="store_true", help="Skip tarfile extract when examining a src.rpm")
        p.add_option('-S', '--source-only', dest="sourceonly", default=False, action="store_true", help="Limit query to source files (no patches)")
    p.add_option('-T', '--suppresstag', dest="suppresstag", default=False, action="store_true", help="Suppress Tag and Path label output for queries") # was only in rqs -- why?
    p.add_option('-x', '--statistics', dest="stats", default=False, action="store_true", help="Show database statistics")
    p.add_option('-v', '--verbose', dest="verbose", default=False, action="store_true", help="Verbose output")
    dbgroup = optparse.OptionGroup(p, "Database Options")
    dbgroup.add_option('-a', '--add', dest="addfile", help="Add a " + rq_type + " rpm entry with TAG to the database", metavar="FILE")
    dbgroup.add_option('-c', '--createpath', dest="createpath", help="Create database entries with TAG from a " + rq_type + " rpm DIR", metavar="DIR")
    dbgroup.add_option('-D', '--delete', dest="tagdelete", help="Delete all TAG entries", metavar="TAG")
    if rq_type == 'source':
        dbgroup.add_option('-f', '--file', dest="src_examine", help="Examine a src.rpm FILE and output to stdout", metavar="FILE")
    dbgroup.add_option('-t', '--tag', dest="tag", help="TAG for created database entries or database queries", metavar="TAG")
    dbgroup.add_option('-u', '--update', dest="tagupdate", help="Update TAG entries (new/removed files in directory)", metavar="TAG")
    p.add_option_group(dbgroup)
    group = optparse.OptionGroup(p, "Query Options")
    if rq_type == 'binary':
        group.add_option('-p', '--provides', dest="provides", help="Query database for substring match on provides", metavar="STRING")
    group.add_option('-q', '--query', dest="query", help="Query database for substring match on files", metavar="STRING")
    if rq_type == 'binary':
        group.add_option('-r', '--requires', dest="requires", help="Query database for substring match on requires", metavar="STRING")
    p.add_option_group(group)
    (options, arguments) = p.parse_args()       # 'arguments' is a tuple of non-optioned things

    if len(sys.argv) == 1:      # no arguments passed
        p.print_help()
        sys.exit(0)

    # setup the options
    if rq_type == 'binary':
        if options.provides and options.query:
            p.error("--provides and --query are mutually exclusive")
        if options.provides and options.requires:
            p.error("--provides and --requires are mutually exclusive")
        if options.query and options.requires:
            p.error("--query and --provides are mutually exclusive")
        if options.provides and options.query and options.requires:
            p.error("--query, --provides, and --requires are mutually exclusive")

    if options.verbose and options.quiet:
        p.error("--quiet and --verbose are mutually exclusive")
    if options.tag and options.tagdelete:
        p.error("--tag and --delete are mutually exclusive; you do not need to use --tag")

    if options.debug:
        print_debug("debug mode enabled; type => " + rq_type)

    if options.verbose:
        print_verbose("Verbose mode enabled")

    config = {}

    config_file = '/etc/rqrc'
    if os.path.isfile(config_file):             # look for a system-wide one first
        config = read_config(config_file)

    config_file = os.getenv('HOME') + '/.rqrc'
    if os.path.isfile(config_file):             # if we find a local one, overwrite anything defined
        config = read_config(config_file)

    if not config:
        sys.stderr.write('\n\nERROR: No configuration file found!\n')
        sys.exit(1)

    (db, config) = db_connect(rq_type, config)

    # start doing useful things
    if options.list:
        tag_list()

    if options.stats:
        showdbstats(rq_type)

    if options.tag:
        print_debug('Tag:\t%s\n' % options.tag)

    if options.tagdelete:
        tag_delete_entries(options.tagdelete, rq_type)
        sys.exit(0)

    if options.tagupdate:
        tag_update_entries(options.tagupdate, rq_type)
        sys.exit(0)

    if options.query:
        if rq_type == 'binary':
            run_binary_query(options.query, 'files')
        elif rq_type == 'source':
            run_source_query(options.query)
        sys.exit(0)

    if rq_type == 'binary':
        if options.provides:
            run_binary_query(options.provides, 'provides')
            sys.exit(0)

        if options.requires:
            run_binary_query(options.requires, 'requires')
            sys.exit(0)

    if rq_type == 'source':
        if options.src_examine:
            run_source_examine(options.src_examine)
            sys.exit(0)

    # this option is strange... it must be for adding a file, but should a single file
    # have a new tag?  or can we add it (despite the path) to an existing tag?
    # XXX: it also needs to be able to support numerous files at once
    # XXX: TODO
    if options.addfile:
        if not options.tag:
            sys.stdout.write('The --add option requires a tag entry!\n')
            sys.exit(1)

        havetag = tag_check(options.tag, options.addfile)
        print_debug('havetag is: %s' % havetag)

        if not havetag:
            sys.stderr.write('The --add option requires an existing tag entry!\n')
            sys.exit(1)

        addfiles = []
        addfiles.append(options.addfile)

        if len(arguments) > 0:
            addfiles.extend(arguments)

        for afile in addfiles:
            record_add(options.tag, afile, rq_type)

        sys.exit(0)

    if options.createpath:
        createpath = os.path.abspath(options.createpath)
        print_debug('Dir:\t%s' % createpath)
        if not options.tag:
            sys.stdout.write('The --create option requires a tag entry!\n')
            sys.exit(1)

        sys.stdout.write('Searching for rpms to import...\n\n')
        rpm_add_directory(options.tag, createpath, rq_type)
        sys.exit(0)

    # if we get here, we have completely invalid arguments
    p.print_help()
    sys.exit(0)
