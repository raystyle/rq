#!/usr/bin/env python
"""
This program extracts data from RPM and SRPM packages and stores it in
a database for later querying.

based on the srpm script of similar function copyright (c) 2005 Stew Benedict <sbenedict@mandriva.com>
copyright (c) 2007-2009 Vincent Danen <vdanen@linsec.ca>

$Id$
"""

import optparse, os, sys, re, datetime, commands, shutil, tempfile, logging
#import MySQLdb, MySQLdb.cursors
import rq.db
import rq.basics
import rq.tag
from glob import glob
#import MySQLdb.connect

re_srpm    = re.compile(r'\.src\.rpm$')
re_brpm    = re.compile(r'\.rpm$')
re_patch   = re.compile(r'\.(diff|dif|patch)(\.bz2|\.gz)?$')
re_tar     = re.compile(r'\.((tar)(\.bz2|\.gz)?|t(gz|bz2?))$')
re_targz   = re.compile(r'\.(tgz|tar\.gz)$')
re_tarbz   = re.compile(r'\.(tbz2?|tar\.bz2)$')
re_patchgz = re.compile(r'\.(patch|diff|dif)(\.gz)$')
re_patchbz = re.compile(r'\.(patch|diff|dif)(\.bz2)$')

file_excludes = ('/.svn', '/CVS', 'AUTHORS', 'Makefile', 'ChangeLog', 'COPYING', 'TODO', 'README')


def fix_excludes(file):
    """
    if this is a directory exclude, remove the leading '/' for the tar extract
    """
    if file[0] == '/':
        file = file[1:]

    return file


def showdbstats(type, tag):
    """
    Function to show database info
    """
    logging.debug("in showdbstats(%s, %s)" % (type, tag))

    if tag == 'all':
        extra_opts = ''
    else:
        tag_id = rtag.lookup(tag)
        if tag_id:
            extra_opts = "WHERE t_record = '%d'" % tag_id['id']
        else:
            print 'No such tag: "%s" does not exist in the database!\n' % tag
            sys.exit(1)

    query   = "SELECT count(*) FROM tags %s" % extra_opts
    c_tags  = rq.db.fetch_one(db, query)
    query   = "SELECT count(*) FROM packages %s" % extra_opts
    c_pkgs  = rq.db.fetch_one(db, query)
    if type == 'binary':
        query   = "SELECT count(*) FROM requires %s" % extra_opts
        c_reqs  = rq.db.fetch_one(db, query)
        query   = "SELECT count(*) FROM provides %s" % extra_opts
        c_provs = rq.db.fetch_one(db, query)
    else:
        query   = "SELECT count(*) FROM sources %s" % extra_opts
        c_src   = rq.db.fetch_one(db, query)
        query   = "SELECT count(*) FROM ctags %s" % extra_opts
        c_ctags = rq.db.fetch_one(db, query)
        query   = "SELECT count(*) FROM buildreqs %s" % extra_opts
        c_breqs = rq.db.fetch_one(db, query)
    query   = "SELECT count(*) FROM files %s" % extra_opts
    c_files = rq.db.fetch_one(db, query)

    # get the size of the database as well
    size   = 0.00
    bytes  = ''
    query  = "SHOW TABLE STATUS"
    tbsize = rq.db.fetch_all(db, query)

    for x in tbsize:
        size += x['Data_length']
    count = 0

    while size > 1024:
        size   = size / 1024
        count += 1
        if count == 1:
            bytes = 'KB'
        if count == 2:
            bytes = 'MB'
        if count == 3:
            bytes = 'GB'
            break

    print 'Database statistics:\n'
    if tag != 'all':
        print 'Printing statistics for tag: %s\n' % tag
    print '   Database  => User: %s, Host: %s, Database: %s' % (config['username'], config['hostspec'], config['database'])
    print '   Data size => %2.2f %s\n' % (size, bytes)
    print '   Tag records  : %-16d Package records : %-15d' % (c_tags, c_pkgs)
    if type == 'binary':
        print '   File records : %-15d  Requires records: %-15d' % (c_files, c_reqs)
        print '                                   Provides records: %-15d\n' % c_provs
    else:
        print '   File records : %-15d  Source records  : %-15d' % (c_files, c_src)
        print '   Ctags records: %-15d  Requires records: %-15d '% (c_ctags, c_breqs)
    sys.exit(0)


def show_progress(prefix=False):
    """
    Function to show progress
    """
    global pstate

    if not options.verbose and not options.debug and options.progress:
        if not prefix:
            if pstate == 1:
                sys.stdout.write('.')
                sys.stdout.flush()
            pstate = pstate + 1
            if pstate > 150:
                pstate = 1
            return

        if prefix != 'files' and prefix != 'sources' and prefix != '':
            sys.stdout.write("%s: " % prefix.strip())
            sys.stdout.flush()
            pstate = 1
            return
        elif prefix != lprefix:
            sys.stdout.write('\t%s: ' %prefix)
            sys.stdout.flush()
            lprefix = prefix
            return


def get_file_mode(mode):
    """
    Function to return the numeric file mode given the r--r--r-- string as input
    """
    user  = mode[1:4]
    group = mode[4:7]
    other = mode[7:]
    perms = {'user': user, 'group': group, 'other': other}

    num   = 0
    for type in perms.keys():

        read    = perms[type][0]
        write   = perms[type][1]
        execute = perms[type][2]

        if type == 'user':
            if read == 'r':
                num = num + 400
            if write == 'w':
                num = num + 200
            if execute == 'x':
                num = num + 100
            elif execute == 'S':
                num = num + 4000
            elif execute == 's':
                num = num + 4100
        if type == 'group':
            if read == 'r':
                num = num + 40
            if write == 'w':
                num = num + 20
            if execute == 'x':
                num = num + 10
            elif execute == 'S':
                num = num + 2000
            elif execute == 's':
                num = num + 2010
        if type == 'other':
            if read == 'r':
                num = num + 4
            if write == 'w':
                num = num + 2
            if execute == 'x':
                num = num + 1
    num = '%04d' % num
    return(num)


def record_add(tag_id, file, type):
    """
    Function to add a record to the database
    """
    logging.debug('in record_add(%s, %s, %s)' % (tag_id, file, type))

    if os.path.isfile(file):
        path = os.path.abspath(os.path.dirname(file))
    else:
        path = os.path.abspath(file)
    logging.debug('Path:\t%s' % path)

    file_rpm_check(file, type)

    record = package_add_record(tag_id, file, type)
    if not record:
        return

    file_list = rpm_list(file)
    if not file_list:
        return

    if type == 'binary':
        logging.debug('Add file records for package record: %s' % record)
        add_file_records(tag_id, record, file_list)
        add_file_requires(tag_id, record, file)
        add_file_provides(tag_id, record, file)

    if type == 'source':
        logging.debug('Add source records for package record: %s' % record)
        add_source_records(tag_id, record, file_list)
        cpio_dir = tempfile.mkdtemp()

        try:
            current_dir = os.getcwd()
            os.chdir(cpio_dir)
            source_get_all_files(file)
            add_source_file_records(tag_id, record, file_list)
            add_source_ctag_records(tag_id, record, cpio_dir)
            add_source_buildreq_records(tag_id, record, cpio_dir)
            os.chdir(current_dir)
        finally:
            logging.debug('Removing temporary directory: %s...' % cpio_dir)
            shutil.rmtree(cpio_dir)

    if options.progress:
        sys.stdout.write('\n')


def source_get_all_files(file):
    """
    Function to get the source and patch files from a SRPM
    """
    logging.debug('in source_get_all_files(%s)' % file)
    source_get_tar_files(file)
    source_get_patch_files(file)


def source_get_tar_files(file):
    """
    Function to get the tar files from a SRPM

    cpio --quiet is a GNU-ism and isn't portable
    """
    logging.debug('in source_get_tar_files(%s)' % file)

    # include the .spec file here; we need it later
    exts = ['*.tar.?z*', '*.tgz', '*.tbz', '*.zip', '*.spec']
    for search in exts:
        command      = 'rpm2cpio "%s" | cpio -i "%s" 2>/dev/null' % (file, search)
        (rc, output) = commands.getstatusoutput(command)
        logging.debug('called cpio (rc=%s): %s' % (rc, command))

#    if not rc == 0:
#        logging.critical('Failed to execute rpm2cpio!  Command was: %s\nOutput was:\n(rc: %s) %s\n' % (command, rc, output))
#        sys.exit(1)


def source_get_patch_files(file):
    """
    Function to get the patch files from a SRPM
    """
    logging.debug('in source_get_patch_files(%s)' % file)

    exts = ['*patch*', '*diff*']
    for search in exts:
        command      = 'rpm2cpio "%s" | cpio -i "%s" 2>/dev/null' % (file, search)
        (rc, output) = commands.getstatusoutput(command)
        logging.debug('called cpio (rc=%s): %s' % (rc, output))

#    if not rc == 0:
#        logging.critical('Failed to execute rpm2cpio!  Command was: %s\nOutput was:\n(rc: %s) %s\n' % (command, rc, output))
#        sys.exit(1)


def add_file_requires(tag_id, record, file):
    """
    Function to add requires to the database
    """
    logging.debug('in add_file_requires(%s, %s, %s)' % (tag_id, record, file))

    list = commands.getoutput("rpm -qp --nosignature --requires " + file.replace(' ', '\ ') + " | egrep -v '(rpmlib|GLIBC|GCC|rtld)' | uniq")
    list = list.splitlines()
    for dep in list:
        if dep:
            show_progress()
            if options.verbose:
                print 'Dependency: %s' % dep
            query  = "INSERT INTO requires (t_record, p_record, requires) VALUES ('%s', '%s', '%s')" % (tag_id, record, rq.db.sanitize_string(dep.strip()))
            result = rq.db.do_query(db, query)


def add_file_provides(tag_id, record, file):
    """
    Function to add provides to the database
    """
    logging.debug('in add_file_provides(%s, %s, %s)' % (tag_id, record, file))

    list = commands.getoutput("rpm -qp --nosignature --provides " + file.replace(' ', '\ '))
    list = list.splitlines()
    for prov in list:
        if prov:
            show_progress()
            if options.verbose:
                print 'Provides: %s' % prov
            query  = "INSERT INTO provides (t_record, p_record, provides) VALUES ('%s', '%s', '%s')" % (tag_id, record, rq.db.sanitize_string(prov.strip()))
            result = rq.db.do_query(db, query)


def rpm_list(file, raw=False):
    """
    Function to get the list of files in an RPM, excluding those files defined
    by files_exclude
    """
    logging.debug('in rpm_list(%s)' % file)

    list  = commands.getoutput("rpm -qlvp --nosignature " + file.replace(' ', '\ '))

    if list == '(contains no files)' or list == '':
        return False

    if raw:
        return(list)

    list  = list.splitlines()
    rlist = {}
    count = 0

    for entry in list:
        break_loop = False
        logging.debug('processing: %s' % entry) ### DEBUG
        for exclude in file_excludes:
            # make sure we don't include any files in our exclude list
            if re.search(exclude, entry):
                logging.debug('found unwanted entry: %s' % entry)
                break_loop = True

        if break_loop:
            continue

        is_suid = 0
        is_sgid = 0
        foo     = entry.split()

        # this actually really stinks because we are allowed usernames longer
        # than 8 characters, but rpm -qlv will only display the first 8 characters
        # of the owner/group name -- not cool at all
        if len(foo[2]) > 8:
            user  = foo[2][:8]
            group = foo[2][8:]
            fname = foo[7]
        else:
            user  = foo[2]
            group = foo[3]
            fname = foo[8]
        if foo[0][3].lower() == 's':
            is_suid = 1
        if foo[0][6].lower() == 's':
            is_sgid = 1

        perms = get_file_mode(foo[0])

        rlist[count] = {'file': fname, 'user': user, 'group': group, 'is_suid': is_suid, 'is_sgid': is_sgid, 'perms': perms}
        count       += 1

    return(rlist)


def rpm_add_directory(tag, path, type='binary'):
    """
    Function to import a directory full of RPMs
    """
    logging.debug('in rpm_add_directory(%s, %s, %s)' % (tag, path, type))

    if not os.path.isdir(path):
        print 'Path (%s) is not a valid directory!' % path
        sys.exit(1)

    if type == 'binary':
        file_list = glob(path + "/*.rpm")
        file_list.sort()

    if type == 'source':
        file_list = glob(path + "/*.src.rpm")
        file_list.sort()

    if not file_list:
        print 'No files found to import in directory: %s' % path
        sys.exit(1)

    tag_id = rtag.add_record(tag, path)
    if tag_id == 0:
        logging.critical('Unable to add tag "%s" to the database!' % tag)
        sys.exit(1)

    for file in file_list:
        if not os.path.isfile(file):
            print 'File %s not found!\n' % file
            next

        if type == 'binary':
            if not re_brpm.search(file) or re_srpm.search(file):
                print 'File %s is not a binary rpm!\n' % file
                next

        if type == 'source':
            if not re_srpm.search(file):
                print 'File %s is not a source rpm!\n' % file
                next

        record_add(tag_id, file, type)


def add_file_records(tag_id, record, file_list):
    """
    Function to add file records
    """
    logging.debug('in add_file_records(%s, %s, %s)' % (tag_id, record, file_list))

    for x in file_list.keys():
        show_progress()
        if options.verbose:
            print 'File: %s' % file_list[x]['file']
        query  = "INSERT INTO files (t_record, p_record, files, f_user, f_group, f_is_suid, f_is_sgid, f_perms) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d, %s)" % (
            tag_id,
            record,
            rq.db.sanitize_string(file_list[x]['file'].strip()),
            rq.db.sanitize_string(file_list[x]['user']),
            rq.db.sanitize_string(file_list[x]['group']),
            file_list[x]['is_suid'],
            file_list[x]['is_sgid'],
            file_list[x]['perms'])
        result = rq.db.do_query(db, query)


def add_source_records(tag_id, record, file_list):
    """
    Function to add source records
    """
    logging.debug('in add_source_records(%s, %s, %s)' % (tag_id, record, file_list))

    for x in file_list.keys():
        # remove any possible paths from source files; may be due to rpm5
        sfile = file_list[x]['file'].split('/')[-1]
        logging.debug('processing source: %s ' % sfile)
        show_progress()
        stype = ''

        if re_patch.search(sfile):
            stype = 'P'
        if re_tar.search(sfile):
            stype = 'S'

        # we only care about source and patch files, nothing else
        if stype == '':
            continue

        if options.verbose:
            print 'Source: %s, Type: %s' % (sfile, stype)
        query  = "INSERT INTO sources (t_record, p_record, s_type, s_file) VALUES ('%s', '%s', '%s', '%s')" % (tag_id, record, stype, rq.db.sanitize_string(sfile.strip()))
        result = rq.db.do_query(db, query)


def add_source_file_records(tag_id, record, file_list):
    """
    Function to add all source file records
    """
    logging.debug('in add_source_file_records(%s, %s, %s)' % (tag_id, record, file_list))

    for x in file_list.keys():
        good_src = False
        # file_list may contain paths, so strip them; may be due to rpm5
        sfile    = file_list[x]['file'].split('/')[-1]
        logging.debug('processing file: %s' % sfile) ### DEBUG

        if re_patch.search(sfile):
            flist    = patch_list(sfile)
            good_src = True

        if re_tar.search(sfile):
            flist    = tar_list(sfile)
            good_src = True

        # only proceed for tarballs and patches
        if good_src:
            logging.debug('found good file to process: %s' % sfile)
            files = flist.split()

            # get the s_record for this source from the db
            query   = "SELECT s_record FROM sources WHERE p_record = '%s' AND s_file = '%s'" % (record, rq.db.sanitize_string(sfile))
            db_srec = rq.db.fetch_one(db, query)
            if not db_srec:
                logging.critical('adding files from %s failed...' % sfile)
                sys.exit(1)

            for dfile in files:
                break_loop = False
                if dfile.endswith('/'):     # skip directories
                    pass
                else:
                    for exclude in file_excludes:
                        # make sure we don't include any files in our exclude list
                        if re.search(exclude, dfile):
                            logging.debug('found unwanted entry: %s' % dfile)
                            break_loop = True
                    if break_loop == True:
                        pass
                    else:
                        show_progress()
                        if options.verbose:
                            print 'File: %s' % dfile
                        query  = "INSERT INTO files (t_record, p_record, s_record, f_file) VALUES ('%s', '%s', '%s', '%s')" % (tag_id, record, db_srec, rq.db.sanitize_string(dfile))
                        result = rq.db.do_query(db, query)
        else:
            logging.debug('unwilling to process: %s' % sfile)


def add_source_ctag_records(tag_id, record, cpio_dir):
    """
    Function to run ctags against an unpacked source directory
    and insert records into the database
    """
    logging.debug('in add_source_ctag_records(%s, %s, %s)' % (tag_id, record, cpio_dir))

    # this is likely a double chdir, but let's make sure we're in the right place
    # so we don't have to strip out the path from the ctags output
    os.chdir(cpio_dir)

    # first, identify and expand any tarballs found:
    for file in os.listdir(cpio_dir):
        if re_tar.search(file):
            # get the s_record for this source from the db
            query   = "SELECT s_record FROM sources WHERE p_record = '%s' AND s_file = '%s'" % (record, rq.db.sanitize_string(file))
            db_srec = rq.db.fetch_one(db, query)
            if not db_srec:
                logging.critical('!!!!! adding files from %s failed...' % file)
                # don't bail, it's logged, continue
                #sys.exit(1)
                continue

            comp = 'xf'
            if re_targz.search(file):
                comp = 'xzf'
            if re_tarbz.search(file):
                comp = 'xjf'

            excludes = ''
            for f in file_excludes:
                f = fix_excludes(f)

                excludes = '%s --exclude=%s' % (excludes, f)

            tmpdir  = tempfile.mkdtemp()
            command = 'tar -%s "%s" -C %s %s 2>/dev/null' % (comp, file.replace(' ', '\ '), tmpdir, excludes)

            (rc, list) = commands.getstatusoutput(command)
            logging.debug('called tar (rc=%s): %s\n%s' % (rc, command, list))

            os.chdir(tmpdir)

            # some packages contain files that are r--r--r-- which prevents
            # us from cleanly removing the directory, so do a recursive
            # chmod first
            command = "chmod -R u+rwx ."
            (rc, output) = commands.getstatusoutput(command)
            logging.debug('called chmod (rc=%s): %s' % (rc, command))

            command = "ctags -x -R -f - ."
            (rc, output) = commands.getstatusoutput(command)
            logging.debug('called ctags (rc=%s): %s' % (rc, command))

            for tag in output.split('\n'):
                try:
                    (name, type, line, path, extra) = tag.split(None, 4)
                except:
                    continue

                # only store some ctags info, not all of it
                wanted = ['function', 'macro', 'subroutine', 'class', 'method']
                if type in wanted:
                    show_progress()
                    query = "INSERT INTO ctags (t_record, p_record, s_record, c_name, c_type, c_line, c_file, c_extra) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')" % (
                        tag_id,
                        record,
                        db_srec,
                        rq.db.sanitize_string(name),
                        rq.db.sanitize_string(type),
                        rq.db.sanitize_string(line),
                        rq.db.sanitize_string(path),
                        rq.db.sanitize_string(extra))
                    result = rq.db.do_query(db, query)
                    #print '%s\n' % query
            os.chdir(cpio_dir)

            # have to put this in a try statement; who puts files and directories in a tarball all mode 0200?!?
            try:
                shutil.rmtree(tmpdir)
            except:
                logging.critical('Unable to remove directory: %s, most likely because the tarball has idiotic permissions' % tmpdir)


def add_source_buildreq_records(tag_id, record, cpio_dir):
    """
    Get the build requirements for this package from the spec file
    """
    logging.debug('in add_source_buildreq_records(%s, %s, %s)' % (tag_id, record, cpio_dir))

    specfile = ''
    r        = []

    # this is likely a double chdir, but let's make sure we're in the right place
    # so we don't have to strip out the path from the ctags output
    os.chdir(cpio_dir)

    for file in os.listdir(cpio_dir):
        if re.search('.spec', file):
            specfile = file

    if specfile == '':
        logging.critical('No specfile found, unable to process buildrequirements')
        sys.exit(1)

    for line in open(specfile):
        reqs  = {}
        count = 0
        if re.search('^buildrequire', line.lower()):
            words = line.split()
            for c in words:
                if not c.startswith('Build'):
                    reqs[count] = c.strip()
                    count += 1

        # if there is more than one item on this line
        if len(reqs) > 1:
            skip = 0
            for x in reqs.keys():
                # iterate through each item on the line, if this item includes
                # the >, <, or = characters, create our requirement string
                # based on the N+1 and N+2 words
                new = ''

                if skip == 0 and x+1 in reqs.keys():
                    if re.search('(>|<|=)', reqs[x+1]):
                        # construct the new string based on N+1 (equality) and N+2 (nvr)
                        new = '%s %s %s' % (reqs[x], reqs[x+1], reqs[x+2])
                        # tell it to skip the next item since we grabbed it
                        skip += 1
                    else:
                        new = reqs[x]

                elif skip == 0:
                    # there is no following equality string, so take it as it is
                    new = reqs[x]

                else:
                    if skip == 1:
                        # skipped the equality, so skip one more (nvr)
                        skip += 1
                    else:
                        # skip would be 2, so reset the counter
                        skip = 0

                if new.endswith(','):
                    # multi-item dependencies, uses ',' as a delimiter so remove it
                    new = new[:-1]

                # we want to make sure we don't list the same thing twice, we also don't want blank items
                if not new in r:
                    if new != '':
                        r.append(new)

        elif len(reqs) == 1:
            # exactly one item on this line, put it in as-is
            if reqs[0].endswith(','):
                new = reqs[0][:-1]
            else:
                new = reqs[0]
            r.append(new)

    for require in r:
        # now iterate through each item and add them to the database
        show_progress()
        # record == p_record
        query = "INSERT INTO buildreqs (t_record, p_record, b_req) VALUES ('%s', '%s', '%s')" % (
                        tag_id,
                        record,
                        rq.db.sanitize_string(require))
        result = rq.db.do_query(db, query)
        #print '%s\n' % query


def patch_list(file):
    """
    Function to get a list of files that a patch touches
    """
    logging.debug('in patch_list(%s)' % file)

    grep = 'grep'

    if re_patchgz.search(file):
        grep = 'zgrep'

    if re_patchbz.search(file):
        grep = 'bzgrep'

    list = commands.getoutput(grep + " '^+++' " + file.replace(' ', '\ ') + " 2>/dev/null | awk '{print $2}'")

    return(list)


def tar_list(file):
    """
    Function to get a list of files in a tarball
    """
    logging.debug('in tar_list(%s)' % file)

    comp = 'tf'
    if re_targz.search(file):
        comp = 'tzf'
    if re_tarbz.search(file):
        comp = 'tjf'

    excludes = ''
    for f in file_excludes:
        f = fix_excludes(f)

        excludes = '%s --exclude=%s' % (excludes, f)

    command = 'tar -%s "%s" %s 2>/dev/null' % (comp, file.replace(' ', '\ '), excludes)

    (rc, list) = commands.getstatusoutput(command)
    logging.debug('called tar (rc=%s): %s\n%s' % (rc, command, list))

    return(list)


def package_add_record(tag_id, file, type):
    """
    Function to add a package record
    """
    logging.debug('in package_add_record(%s, %s)' % (tag_id, file))

    path    = os.path.basename(file)
    if type == 'binary':
        rpmtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}|%{ARCH}' " + file.replace(' ', '\ '))
    else:
        rpmtags   = commands.getoutput("rpm -qp --nosignature --qf '%{NAME}|%{VERSION}|%{RELEASE}|%{BUILDTIME}' " + file.replace(' ', '\ '))
    tlist   = rpmtags.split('|')
    logging.debug("tlist is %s " % tlist)
    package = tlist[0].strip()
    version = tlist[1].strip()
    release = tlist[2].strip()
    pdate   = tlist[3].strip()
    if type == 'binary':
        arch    = tlist[4].strip()

    query = "SELECT tag FROM tags WHERE t_record = '%s' LIMIT 1" % tag_id
    tag   = rq.db.fetch_one(db, query)

    if type == 'binary':
        query = "SELECT t_record, p_package, p_version, p_release, p_arch FROM packages WHERE t_record = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s' AND p_arch = '%s'" % (
            tag_id,
            rq.db.sanitize_string(package),
            rq.db.sanitize_string(version),
            rq.db.sanitize_string(release),
            rq.db.sanitize_string(arch))
    else:
        query = "SELECT t_record, p_package, p_version, p_release FROM packages WHERE t_record = '%s' AND p_package = '%s' AND p_version = '%s' AND p_release = '%s'" % (
            tag_id,
            rq.db.sanitize_string(package),
            rq.db.sanitize_string(version),
            rq.db.sanitize_string(release))
    result = rq.db.fetch_all(db, query)
    if result:
        if type == 'binary':
            print 'File %s-%s-%s.%s is already in the database under tag %s' % (package, version, release, arch, tag)
        else:
            print 'File %s-%s-%s is already in the database under tag %s' % (package, version, release, tag)
        return(0)

    ## TODO: we shouldn't have to have p_tag here as t_record has the same info, but it
    ## sure makes it easier to sort alphabetically and I'm too lazy for the JOINs right now

    if type == 'binary':
        query  = "INSERT INTO packages (t_record, p_tag, p_package, p_version, p_release, p_date, p_arch) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s')" % (
            tag_id,
            rq.db.sanitize_string(tag),
            rq.db.sanitize_string(package),
            rq.db.sanitize_string(version),
            rq.db.sanitize_string(release),
            rq.db.sanitize_string(pdate),
            rq.db.sanitize_string(arch))
    else:
        query  = "INSERT INTO packages (t_record, p_tag, p_package, p_version, p_release, p_date) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')" % (
            tag_id,
            rq.db.sanitize_string(tag),
            rq.db.sanitize_string(package),
            rq.db.sanitize_string(version),
            rq.db.sanitize_string(release),
            rq.db.sanitize_string(pdate))
    result = rq.db.do_query(db, query)
    show_progress(path)

    query    = "SELECT p_record FROM packages WHERE t_record = '%s' AND p_package = '%s' ORDER BY p_record DESC" % (tag_id, rq.db.sanitize_string(package))
    p_record = rq.db.fetch_one(db, query)
    if p_record:
            return(p_record)
    else:
        print 'Adding file %s failed!\n' % file
        return(0)


def file_rpm_check(file, type='binary'):
    """
    Function to check whether the file is a source or binary RPM

    The default is binary
    """
    logging.debug('in file_rpm_check(%s, %s)' % (file, type))

    if not os.path.isfile(file):
        print 'File %s not found!\n' % file
        sys.exit(1)

    if type == 'binary':
        if not re_brpm.search(file) or re_srpm.search(file):
            print 'File %s is not a binary rpm!\n' % file
            sys.exit(1)

    if type == 'source':
        if not re_srpm.search(file):
            print 'File %s is not a source rpm!\n' % file
            sys.exit(1)


def run_binary_query(qstring, type):
    """
    Function to run the query for binary RPMs
    """
    logging.debug('in run_binary_query(%s, %s)' % (qstring, type))

    tag_id = rtag.lookup(options.tag)
    if options.tag and not tag_id:
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)

    tag_id =  tag_id['id']

    if not options.quiet:
        print 'Searching database records for substring match for %s (%s)' % (type, qstring)

    if options.ignorecase:
        ignorecase = ''
    else:
        ignorecase = 'BINARY'

    if type == 'files':
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s, f_user, f_group, f_is_suid, f_is_sgid, f_perms FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s %s " % (
            type, type, type, ignorecase, type)
    else:
        # query on type: provides, requires, symbols
        query = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, %s FROM %s LEFT JOIN packages ON (packages.p_record = %s.p_record) WHERE %s %s " % (
            type, type, type, ignorecase, type)

    query = query + "LIKE '%" + rq.db.sanitize_string(qstring) + "%'"

    if options.tag:
        query = "%s AND %s.t_record = '%d'"  % (query, type, tag_id)

    query  = query + " ORDER BY p_tag, p_package, " + type
    result = rq.db.fetch_all(db, query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring (%s)' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring (%s)' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag  = row['p_tag']
            fromdb_rpm  = row['p_package']
            fromdb_ver  = row['p_version']
            fromdb_rel  = row['p_release']
            fromdb_date = row['p_date']
            fromdb_file = row[type]

            if type == 'files':
                fromdb_user    = row['f_user']
                fromdb_group   = row['f_group']
                fromdb_is_suid = row['f_is_suid']
                fromdb_is_sgid = row['f_is_sgid']
                fromdb_perms   = row['f_perms']

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s\n' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                rpm = fromdb_rpm

                if not rpm == lsrc:
                    if type == 'files' and options.ownership:
                        is_suid = ''
                        is_sgid = ''
                        if fromdb_is_suid == 1:
                            is_suid = '*'
                        if fromdb_is_sgid == 1:
                            is_sgid = '*'
                        print '%s: %s (%04d,%s%s,%s%s)' % (rpm, fromdb_file, int(fromdb_perms), is_suid, fromdb_user, is_sgid, fromdb_group)
                    else:
                        print '%s: %s' % (rpm, fromdb_file)

                if options.quiet:
                    lsrc = rpm
                else:
                    if options.extrainfo:
                        rpm_date = datetime.datetime.fromtimestamp(float(fromdb_date))
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", rpm_date.strftime('%a %b %d %H:%M:%S %Y'))
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring (%s)' % (options.tag, qstring)
        else:
            print 'No matches in database for substring (%s)' % qstring


def run_source_query(qstring, type):
    """
    Function to run the query for source RPMs
    """
    logging.debug('in run_source_query(%s, %s)' % (qstring, type))

    if options.tag and not rtag.lookup(options.tag):
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)

    if options.ignorecase:
        ignorecase = ''
    else:
        ignorecase = 'BINARY'

    if type == 'ctags':
        query   = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, s_type, s_file, c_file, c_type, c_extra, c_line FROM ctags JOIN sources ON (sources.s_record = ctags.s_record) JOIN packages ON (packages.p_record = ctags.p_record) WHERE %s c_name " % ignorecase
        orderby = "c_file"
        match_t = 'Ctags data'
    elif type == 'buildreqs':
        query   = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, b_req FROM buildreqs JOIN packages ON (packages.p_record = buildreqs.p_record) WHERE %s b_req " % ignorecase
        match_t = '.spec BuildRequires'
    else:
        query   = "SELECT DISTINCT p_tag, p_package, p_version, p_release, p_date, s_type, s_file, f_file FROM files JOIN sources ON (sources.s_record = files.s_record) JOIN packages ON (packages.p_record = files.p_record) WHERE %s f_file " % ignorecase
        orderby = "f_file"
        match_t = 'files'

    query = query + "LIKE '%" + rq.db.sanitize_string(qstring) + "%'"

    if options.sourceonly:
        query = query + " AND s_type = 'S'"

    if options.tag:
        query = query + " AND p_tag = '" + rq.db.sanitize_string(options.tag) + "'"

    if type == 'buildreqs':
        query   = '%s ORDER BY p_tag, p_package' % query
    else:
        query   = "%s ORDER BY p_tag, p_package, s_type, s_file, %s" % (query, orderby)

    if not options.quiet:
        print 'Searching database records for substring match on %s ("%s")' % (match_t, qstring)

    result = rq.db.fetch_all(db, query)
    if result:
        if options.count:
            if options.quiet:
                print len(result)
            else:
                if options.tag:
                    print '%d match(es) in database for tag (%s) and substring ("%s")' % (len(result), options.tag, qstring)
                else:
                    print '%d match(es) in database for substring ("%s")' % (len(result), qstring)
            return

        ltag = ''
        lsrc = ''
        for row in result:
            # for readability
            fromdb_tag   = row['p_tag']
            fromdb_rpm   = row['p_package']
            fromdb_ver   = row['p_version']
            fromdb_rel   = row['p_release']
            fromdb_date  = row['p_date']
            if type == 'buildreqs':
                fromdb_type  = 'S'
                fromdb_breq  = row['b_req']
            else:
                fromdb_type  = row['s_type']
                fromdb_file  = row['s_file']
                fromdb_sfile = row[orderby]
            if type == 'ctags':
                fromdb_ctype  = row['c_type']
                fromdb_cline  = row['c_line']
                fromdb_cextra = row['c_extra']

            if not ltag == fromdb_tag:
                print '\nResults in Tag: %s\n' % fromdb_tag
                ltag = fromdb_tag

            if options.debug:
                print row
            else:
                srpm  = '%s-%s-%s' % (fromdb_rpm, fromdb_ver, fromdb_rel)
                stype = 'source'

                if options.quiet:
                    lsrc = srpm
                    sys.stdout.write('%s\n' % srpm)
                    sys.stdout.flush()
                else:
                    if fromdb_type == 'P':
                        stype = 'patch'
                    if options.extrainfo:
                        rpm_date = datetime.datetime.fromtimestamp(float(fromdb_date))
                        print '\n%-16s%-30s' % (stype.title() + " File:", fromdb_file)
                        print '%-16s%-30s' % ("Source Path:", fromdb_sfile)
                        print '%-16s%-27s%-9s%s' % ("Package:", fromdb_rpm, "Date:", rpm_date.strftime('%a %b %d %H:%M:%S %Y'))
                        print '%-16s%-27s%-9s%s' % ("Version:", fromdb_ver, "Release:", fromdb_rel)
                    else:
                        if type == 'ctags':
                            sys.stdout.write('%s: (%s) %s\n\tFound matching %s in %s:%s: %s\n' % (srpm, stype, fromdb_file, fromdb_ctype, fromdb_sfile, fromdb_cline, fromdb_cextra))
                        elif type == 'buildreqs':
                            sys.stdout.write('%s: %s\n' % (srpm, fromdb_breq))
                        else:
                            sys.stdout.write('%s: (%s) %s: %s\n' % (srpm, stype, fromdb_file, fromdb_sfile))

    else:
        if options.tag:
            print 'No matches in database for tag (%s) and substring ("%s")' % (options.tag, qstring)
        else:
            print 'No matches in database for substring ("%s")' % qstring


def run_source_examine(file):
    """
    Examine a src.rpm and output the details
    """
    logging.debug('in run_source_examine(%s)' % file)

    file_rpm_check(file, 'source')

    file = path = os.path.abspath(file)

    print 'Examining %s...\n' % file

    # stage 1, list the rpm content
    src_list = rpm_list(file, raw=True)
    print 'SRPM Contents:\n%s\n' % src_list

    file_list = rpm_list(file)

    cpio_dir = tempfile.mkdtemp()
    try:
        current_dir = os.getcwd()
        os.chdir(cpio_dir)

        # stage 2, list patched files
        if options.patch:
            source_get_patch_files(file)
            for x in file_list.keys():
                if re_patch.search(file_list[x]['file']):
                    plist = patch_list(file_list[x]['file'])
                    print 'Patch file %s modifies:\n%s\n' % (file_list[x]['file'], plist)

        # stage 3, list the tarball contents
        if not options.skiptar:
            source_get_tar_files(file)
            for y in file_list.keys():
                if re_tar.search(file_list[y]['file']):
                    tlist = tar_list(file_list[y]['file'])
                    print 'Tarfile %s contents:\n%s\n' % (file_list[y]['file'], tlist)

        os.chdir(current_dir)
    finally:
        logging.debug('Removing temporary directory: %s...' % cpio_dir)
        shutil.rmtree(cpio_dir)


def run_source_showinfo(srpm):
    """
    Display all known information on a srpm
    """
    logging.debug('in run_source_showinfo(%s)' % srpm)

    if options.tag and not rtag.lookup(options.tag):
        print 'Tag %s is not a known tag!\n' % options.tag
        sys.exit(1)

    print 'Displaying all known information on srpm "%s"\n' % srpm

    if options.tag:
        qtag = " AND p_tag = '%s'" % rq.db.sanitize_string(options.tag)
    else:
        qtag = ''

    query = "SELECT * FROM packages JOIN tags ON (packages.t_record = tags.t_record) WHERE p_package = '%s' %s ORDER BY p_tag" % (rq.db.sanitize_string(srpm), qtag)

    result = rq.db.fetch_all(db, query)
    if not result:
        print 'No matches found for package %s' % srpm
        sys.exit(0)

    for row in result:
        print 'Results for package %s-%s-%s' % (row['p_package'], row['p_version'], row['p_release'])
        print '  Tag: %-20s Source path: %s' % (row['p_tag'], row['path'])

        query   = "SELECT s_file FROM sources WHERE p_record = '%s' ORDER BY s_type, s_file ASC" % row['p_record']
        results = rq.db.fetch_all(db, query)
        if results:
            print ''
            print '  Source RPM contains the following source files:'
            for xrow in results:
                print '  %s' % xrow['s_file']

        query   = "SELECT b_req FROM buildreqs WHERE p_record = '%s' ORDER BY b_req ASC" % row['p_record']
        results = rq.db.fetch_all(db, query)
        if results:
            print ''
            print '  Source RPM has the following BuildRequires:'
            for xrow in results:
                print '  %s' % xrow['b_req']
        print ''




if __name__ == '__main__':
    """
    The main program
    """
    global options, config

    rq_version = '0.3'
    if os.path.basename(sys.argv[0]) == 'rqs':
        rq_prog    = 'rqs'
        rq_type    = 'source'
    else:
        rq_prog    = 'rqp'
        rq_type    = 'binary'

    sys.stdout.write("%s %s ($Id$)\n\n" % (rq_prog, rq_version))
    # XXX: TODO add options to search files by ownership and sgid/suid status

    p = optparse.OptionParser(description="RPM package query tool",
                              prog=rq_prog,
                              version="%prog " + rq_version,
                              usage="%prog [-h] [-v] [-c <directory>] [-[q|r|p|z] <substring>] [-t <tag>]")
    p.add_option('-n', '--config', dest="conffile", help="Optional configuration file", metavar="FILE")
    p.add_option('-C', '--count', dest="count", default=False, action="store_true", help="Only output the count of query matches")
    p.add_option('-d', '--debug', dest="debug", default=False, action="store_true", help="Enable debugging output")
    p.add_option('-e', '--extrainfo', dest="extrainfo", default=False, action="store_true", help="Show extra info (version, release, date)")
    p.add_option('-i', '--ignorecase', dest="ignorecase", default=False, action="store_true", help="Case insensitive search")
    p.add_option('-l', '--list', dest="list", default=False, action="store_true", help="List database tags")
    if rq_type == 'binary':
        p.add_option('-o', '--ownership', dest="ownership", default=False, action="store_true", help="Display ownership information on files")
    if rq_type == 'source':
        p.add_option('-p', '--patch', dest="patch", default=False, action="store_true", help="List patched files when examining a src.rpm")
    p.add_option('-P', '--progress', dest="progress", default=False, action="store_true", help="Show processing progress")
    p.add_option('-Q', '--quiet', dest="quiet", default=False, action="store_true", help="Quiet query - show tag and package name only (or numeric count only)")
    if rq_type == 'source':
        p.add_option('-s', '--skip-tar', dest="skiptar", default=False, action="store_true", help="Skip tarfile extract when examining a src.rpm")
        p.add_option('-S', '--source-only', dest="sourceonly", default=False, action="store_true", help="Limit query to source files (no patches)")
    p.add_option('-T', '--suppresstag', dest="suppresstag", default=False, action="store_true", help="Suppress Tag and Path label output for queries") # was only in rqs -- why?
    p.add_option('-x', '--statistics', dest="stats", default=False, action="store_true", help="Show database statistics")
    p.add_option('-v', '--verbose', dest="verbose", default=False, action="store_true", help="Verbose output")
    dbgroup = optparse.OptionGroup(p, "Database Options")
    dbgroup.add_option('-a', '--add', dest="addfile", help="Add a " + rq_type + " rpm entry with TAG to the database", metavar="FILE")
    dbgroup.add_option('-c', '--createpath', dest="createpath", help="Create database entries with TAG from a " + rq_type + " rpm DIR", metavar="DIR")
    dbgroup.add_option('-D', '--delete', dest="tagdelete", help="Delete all TAG entries", metavar="TAG")
    if rq_type == 'source':
        dbgroup.add_option('-f', '--file', dest="src_examine", help="Examine a src.rpm FILE and output to stdout", metavar="FILE")
    dbgroup.add_option('-t', '--tag', dest="tag", help="TAG for created database entries or database queries", metavar="TAG")
    dbgroup.add_option('-u', '--update', dest="tagupdate", help="Update TAG entries (new/removed files in directory)", metavar="TAG")
    p.add_option_group(dbgroup)
    group = optparse.OptionGroup(p, "Query Options")
    if rq_type == 'binary':
        group.add_option('-p', '--provides', dest="provides", help="Query database for substring match on provides", metavar="STRING")
    group.add_option('-q', '--query', dest="query", help="Query database for substring match on files", metavar="STRING")
    if rq_type == 'binary':
        group.add_option('-r', '--requires', dest="requires", help="Query database for substring match on requires", metavar="STRING")
        group.add_option('-z', '--symbols', dest="symbols", help="Query database for substring match on symbols in binary files", metavar="STRING")
    if rq_type == 'source':
        group.add_option('-b', '--buildreqs', dest="buildreqs", help="Query database for substring match on BuildRequires", metavar="STRING")
        group.add_option('-o', '--info', dest="showinfo", help="Show all info on specified srpm", metavar="STRING")
        group.add_option('-z', '--ctags', dest="ctags", help="Query database for substring match on ctags data (functions, etc.)", metavar="STRING")
    p.add_option_group(group)
    (options, arguments) = p.parse_args()       # 'arguments' is a tuple of non-optioned things

    if len(sys.argv) == 1:      # no arguments passed
        p.print_help()
        sys.exit(0)

    # setup the options
    if rq_type == 'binary':
        if options.provides and options.query:
            p.error("--provides and --query are mutually exclusive")
        if options.provides and options.requires:
            p.error("--provides and --requires are mutually exclusive")
        if options.query and options.requires:
            p.error("--query and --provides are mutually exclusive")
        if options.provides and options.query and options.requires:
            p.error("--query, --provides, and --requires are mutually exclusive")

    if options.verbose and options.quiet:
        p.error("--quiet and --verbose are mutually exclusive")
    if options.tag and options.tagdelete:
        p.error("--tag and --delete are mutually exclusive; you do not need to use --tag")

    # setup logging facilities
    LOG_FILENAME = '%s/%s.log' % (os.getcwd(), rq_prog)
    LEVELS = {'debug'  : logging.DEBUG,
              'info'   : logging.INFO,
              'warning': logging.WARNING}

    if options.debug:
        filelevel = LEVELS.get('debug', logging.NOTSET)
        conslevel = LEVELS.get('debug', logging.NOTSET)
        filefmt   = '%(asctime)s %(filename)s(%(funcName)s[%(lineno)d]): %(levelname)s: %(message)s'

    if options.verbose:
        filelevel = LEVELS.get('info', logging.NOTSET)
        conslevel = LEVELS.get('info', logging.NOTSET)
        filefmt   = '%(asctime)s %(message)s'

    if not options.verbose and not options.debug:
        filelevel = LEVELS.get('info', logging.NOTSET)
        conslevel = LEVELS.get('warning', logging.NOTSET)
        filefmt   = '%(asctime)s %(message)s'

    logging.basicConfig(level=filelevel,
                        format=filefmt,
                        datefmt='%b %d %H:%M:%S',
                        filename=LOG_FILENAME,
                        filemode='a')
    console = logging.StreamHandler()
    console.setLevel(conslevel)
    consfmt = logging.Formatter('%(message)s')
    console.setFormatter(consfmt)
    logging.getLogger('').addHandler(console)

    logging.debug("%s starting, debug mode enabled; type => %s" % (rq_prog, rq_type))

    config = rq.basics.Config(options.conffile)

    (db, config) = rq.db.connect(rq_type, config)

    rtag = rq.tag.Tag(db, rq_type)

    # start doing useful things
    if options.list:
        rtag.list()

    if options.stats:
        if options.tag:
            showdbstats(rq_type, options.tag)
        else:
            showdbstats(rq_type, 'all')

    if options.tag:
        logging.debug('Tag:\t%s\n' % options.tag)

    if options.tagdelete:
        rtag.delete_entries(options.tagdelete)
        sys.exit(0)

    if options.tagupdate:
        rtag.update_entries(options.tagupdate)
        sys.exit(0)

    if options.query:
        if rq_type == 'binary':
            run_binary_query(options.query, 'files')
        elif rq_type == 'source':
            run_source_query(options.query, 'files')
        sys.exit(0)

    if rq_type == 'binary':
        if options.provides:
            run_binary_query(options.provides, 'provides')
            sys.exit(0)

        if options.requires:
            run_binary_query(options.requires, 'requires')
            sys.exit(0)

        if options.symbols:
            run_binary_query(options.symbols, 'symbols')

    if rq_type == 'source':
        if options.ctags:
            run_source_query(options.ctags, 'ctags')
            sys.exit(0)

        if options.buildreqs:
            run_source_query(options.buildreqs, 'buildreqs')
            sys.exit(0)

        if options.showinfo:
            run_source_showinfo(options.showinfo)
            sys.exit(0)

        if options.src_examine:
            run_source_examine(options.src_examine)
            sys.exit(0)

    # this option is strange... it must be for adding a file, but should a single file
    # have a new tag?  or can we add it (despite the path) to an existing tag?
    # XXX: it also needs to be able to support numerous files at once
    # XXX: TODO
    if options.addfile:
        if not options.tag:
            logging.critical('The --add option requires a tag entry!')
            sys.exit(1)

        # are we passed a file, or directory?
        if os.path.isfile(options.addfile):
            # passed a file, we want the path
            path = os.path.abspath(os.path.dirname(options.addfile))
        else:
            # passed a directory
            path = os.path.abspath(options.addfile)

        havetag = rtag.lookup(options.tag)

        if not havetag:
            logging.critical('The --add option requires a tag that already exists!')
            sys.exit(1)

        if path != havetag['path']:
            logging.critical('Tag (%s) is already in the database with path: %s' % (options.tag, havetag['path']))
            logging.critical('Cannot add to an existing tag from a different path!  Unwilling to use %s to add a new file!' % path)
            sys.exit(1)

        # the rest of this just makes no sense as-is so bail
        print 'The --add option is non-functional.  Sorry.'
        sys.exit(1)

        addfiles = []
        addfiles.append(path)

        if len(arguments) > 0:
            addfiles.extend(arguments)

        for afile in addfiles:
            print afile
            #record_add(options.tag, afile, rq_type)

        sys.exit(0)

    if options.createpath:
        createpath = os.path.abspath(options.createpath)
        logging.debug('Dir:\t%s' % createpath)
        if not options.tag:
            sys.stdout.write('The --create option requires a tag entry!\n')
            sys.exit(1)

        sys.stdout.write('Searching for rpms to import...\n\n')
        rpm_add_directory(options.tag, createpath, rq_type)
        sys.exit(0)

    # if we get here, we have completely invalid arguments
    p.print_help()
    sys.exit(0)
